#### **1. Определение**
**Инвалидация итераторов** — это ситуация, когда итератор (или указатель/ссылка) на элемент контейнера перестаёт быть валидным (корректным) из-за изменений в самом контейнере. Использование инвалидированного итератора приводит к **неопределённому поведению** (UB), включая краш программы или повреждение данных.

#### **2. Основные понятия**
- **Валидный итератор**: Корректно указывает на существующий элемент контейнера.  
- **Инвалидированный итератор**: Потерял связь с элементом из-за модификации контейнера (например, удаление, вставка, изменение ёмкости).
- **Неопределённое поведение (UB)**: Любое использование инвалидированного итератора (разыменование, сравнение и т.д.) может привести к непредсказуемым последствиям.

#### **3. Когда происходит инвалидация?**
Инвалидация зависит от типа контейнера и выполняемой операции.

##### **1. Последовательные контейнеры (`std::vector`, `std::string`, `std::deque`)**
- **Полная инвалидация** (все итераторы/указатели/ссылки):
  - При **вставке**, если происходит перевыделение памяти (`reallocation`) из-за нехватки `capacity`.
  - При **удалении** элемента **перед** текущим итератором.
- **Частичная инвалидация** (только на удалённые/изменённые элементы):
  - `erase()`: инвалидирует итераторы на удалённые элементы и все последующие.
  - `resize()`/`pop_back()`: инвалидируют только итераторы на "хвостовые" элементы.  

**Пример для `std::vector`:**
```cpp
std::vector<int> v = {1, 2, 3};
auto it = v.begin() + 1;  // указывает на 2

v.push_back(4);  // Может вызвать reallocation → it инвалидируется!
// UB: std::cout << *it; 
```

##### **2. Двусторонняя очередь (`std::deque`)**
- **Инвалидация частичная или полная**:
  - Вставка/удаление **в начале или конце** (`push_front`, `pop_back` и т.д.) инвалидирует только итераторы на изменённые элементы.
  - Вставка/удаление **в середине** инвалидирует **все** итераторы.

##### **3. Списки (`std::list`, `std::forward_list`)**
- **Устойчивость к инвалидации**:
  - Вставка (`insert`, `push_back`) **не** инвалидирует существующие итераторы.
  - Удаление (`erase`) инвалидирует **только итераторы на удалённые элементы**.

**Пример для `std::list`:**
```cpp
std::list<int> l = {1, 2, 3};
auto it = ++l.begin();  // указывает на 2

l.push_back(4);  // it остаётся валидным
l.erase(it);     // теперь it инвалидирован
```

##### **4. Ассоциативные контейнеры (`std::set`, `std::map`)**
- **Вставка (`insert`)** **не** инвалидирует итераторы.
- **Удаление (`erase`)** инвалидирует **только итераторы на удалённые элементы**.

**Пример для `std::map`:**
```cpp
std::map<int, std::string> m = {{1, "a"}, {2, "b"}};
auto it = m.find(1);

m.erase(2);  // it остаётся валидным
m.erase(it); // теперь it инвалидирован
```

##### **5. Хеш-таблицы (`std::unordered_set`, `std::unordered_map`)**
- **Рехеширование** (при увеличении `load_factor`) инвалидирует **все** итераторы.
  - Происходит при `insert`, если `size > max_load_factor * bucket_count`.
  - Методы `rehash`, `reserve` также могут инвалидировать итераторы.

**Пример для `std::unordered_set`:**
```cpp
std::unordered_set<int> s = {1, 2, 3};
auto it = s.find(2);

s.insert(4);  // Может вызвать рехеширование → it инвалидируется!
// UB: std::cout << *it;
```

#### 4. Применение и примеры
- **Идиома "erase-remove"** для `vector`/`deque`:
  ```cpp
  v.erase(std::remove_if(v.begin(), v.end(), pred), v.end());
  ```  
- **Рекомендации для `unordered_*`**:
  - Заранее вызывать `reserve`, чтобы избежать рехеширования.
  - В C++20 использовать `extract()` для безопасного удаления без инвалидации других итераторов.

#### **5. Плюсы и минусы**
- **Плюсы**:
  - Контейнеры вроде `list` и `map` устойчивы к инвалидации при вставке.
- **Минусы**:
  - `vector` и `unordered_*` подвержены полной инвалидации при изменении ёмкости.

#### **6. Сравнение с другими подходами**
- **`vector` vs `list`**:
  - `vector` быстрее для доступа, но инвалидирует итераторы при reallocation.
  - `list` сохраняет итераторы при вставке, но медленнее для перебора.

#### **7. Best Practices**
1. **Переполучайте итераторы** после модификации контейнера.
2. **Используйте `reserve`** для `vector` и `unordered_*`, чтобы минимизировать reallocation.
3. **Избегайте хранения итераторов** долго — они могут стать невалидными.
4. **В C++20**:
   - `contains()` вместо `find() != end()`.
   - `extract()` для безопасного удаления в ассоциативных контейнерах.

**Идеальный ответ:**
_"Инвалидация итераторов — это потеря валидности итератора из-за модификации контейнера. Для `vector`/`string` она происходит при reallocation, для `unordered_*` — при рехешировании, а `list`/`map` более устойчивы. Чтобы избежать UB, переполучайте итераторы после изменений и используйте `reserve` или `extract()` (C++20)."_