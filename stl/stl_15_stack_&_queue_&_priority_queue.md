#### **1. Определение**
Адаптеры контейнеров (`std::stack`, `std::queue`, `std::priority_queue`) — это специализированные классы, которые предоставляют ограниченный интерфейс для работы с данными, используя базовые контейнеры STL (например, `std::deque`, `std::vector`). Они не являются самостоятельными контейнерами, а "адаптируют" функциональность других контейнеров под конкретные структуры данных.

**Общие характеристики:**
- **Базовый контейнер**:
  - `std::stack`: `std::deque`.
  - `std::queue`: `std::deque`.
  - `std::priority_queue`: `std::vector`.
Можно указать другой контейнер, если он удовлетворяет требованиям адаптера:
```cpp
std::stack<int, std::vector<int>> stk; // Используем vector вместо deque
std::queue<int, std::list<int>> q;     // Используем list вместо deque
std::priority_queue<int, std::deque<int>> pq; // Используем deque вместо vector
```
- **Ограниченный интерфейс**:
    Предоставляют только специфичные для их логики операции.
- **Нет итераторов**:
    Не поддерживают прямой обход элементов.

#### **2. `std::stack`**

**Описание**
`std::stack` реализует стек (LIFO — Last In, First Out). Это означает, что последний добавленный элемент будет первым извлечённым.

**Основные операции**

|**Метод**|**Описание**|**Сложность**|
|---|---|---|
|`push(value)`|Добавляет элемент в вершину стека.|O(1)|
|`pop()`|Удаляет элемент из вершины стека.|O(1)|
|`top()`|Возвращает элемент на вершине (без удаления).|O(1)|
|`empty()`|Проверяет, пуст ли стек.|O(1)|
|`size()`|Возвращает количество элементов.|O(1)|

**Реализация**
По умолчанию `std::stack` использует `std::deque` в качестве базового контейнера. Однако можно использовать и другие контейнеры, такие как `std::vector` или `std::list`.

**Пример**
```cpp
#include <iostream>
#include <stack>

int main() {
    std::stack<int> stk;

    // Добавление элементов
    stk.push(10);
    stk.push(20);
    stk.push(30);

    // Верхний элемент
    std::cout << "Top: " << stk.top() << "\n"; // 30

    // Удаление элемента
    stk.pop();
    std::cout << "Top after pop: " << stk.top() << "\n"; // 20

    return 0;
}
```

#### **3. `std::queue`**

**Описание**
`std::queue` реализует очередь (FIFO — First In, First Out). Это означает, что первый добавленный элемент будет первым извлечённым.

**Основные операции**

|**Метод**|**Описание**|**Сложность**|
|---|---|---|
|`push(value)`|Добавляет элемент в конец очереди.|O(1)|
|`pop()`|Удаляет элемент из начала очереди.|O(1)|
|`front()`|Возвращает первый элемент (без удаления).|O(1)|
|`back()`|Возвращает последний элемент (без удаления).|O(1)|
|`empty()`|Проверяет, пуста ли очередь.|O(1)|
|`size()`|Возвращает количество элементов.|O(1)|

**Реализация**
По умолчанию `std::queue` использует `std::deque` в качестве базового контейнера. Можно также использовать `std::list`.

**Пример**
```cpp
#include <iostream>
#include <queue>

int main() {
    std::queue<int> q;

    // Добавление элементов
    q.push(10);
    q.push(20);
    q.push(30);

    // Первый элемент
    std::cout << "Front: " << q.front() << "\n"; // 10

    // Удаление элемента
    q.pop();
    std::cout << "Front after pop: " << q.front() << "\n"; // 20

    return 0;
}
```

#### **4. `std::priority_queue`**

**Описание**
`std::priority_queue` реализует очередь с приоритетом. Элементы извлекаются в порядке их приоритета (по умолчанию — от наибольшего к наименьшему).

**Основные операции**

|**Метод**|**Описание**|**Сложность**|
|---|---|---|
|`push(value)`|Добавляет элемент с учётом приоритета.|O(log n)|
|`pop()`|Удаляет элемент с наивысшим приоритетом.|O(log n)|
|`top()`|Возвращает элемент с наивысшим приоритетом.|O(1)|
|`empty()`|Проверяет, пуста ли очередь.|O(1)|
|`size()`|Возвращает количество элементов.|O(1)|

**Реализация**
По умолчанию `std::priority_queue` использует `std::vector` в качестве базового контейнера и реализует бинарную кучу (heap) для поддержания порядка элементов, а элементы сортирует по убыванию (`std::less`).

**Пример**
```cpp
#include <iostream>
#include <queue>

int main() {
    std::priority_queue<int> pq;

    // Добавление элементов
    pq.push(10);
    pq.push(30);
    pq.push(20);

    // Наивысший приоритет
    std::cout << "Top: " << pq.top() << "\n"; // 30

    // Удаление элемента
    pq.pop();
    std::cout << "Top after pop: " << pq.top() << "\n"; // 20

    return 0;
}
```

**Настройка приоритета**
Можно изменить порядок приоритета, передав собственный компаратор:
```cpp
#include <iostream>
#include <queue>

struct MinHeap {
    bool operator()(int a, int b) const {
        return a > b; // Минимальный элемент имеет наивысший приоритет
    }
};

int main() {
    std::priority_queue<int, std::vector<int>, MinHeap> pq;

    pq.push(10);
    pq.push(30);
    pq.push(20);

    std::cout << "Top: " << pq.top() << "\n"; // 10

    return 0;
}
```

#### **5. Сравнение адаптеров**

<table>
  <thead>
    <tr>
      <th scope="col">Критерий</th>
      <th scope="col">std::stack</th>
      <th scope="col">std::queue</th>
      <th scope="col">std::priority_queue</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">Порядок элементов</th>
      <td>LIFO</td>
      <td>FIFO</td>
      <td>По приоритету</td>
    </tr>
    <tr>
      <th scope="row">Базовый контейнер</th>
      <td>std::deque</td>
      <td>std::deque</td>
      <td>std::vector</td>
    </tr>
    <tr>
      <th scope="row">Основные операции</th>
      <td>push, pop, top</td>
      <td>push, pop, front</td>
      <td>push, pop, top</td>
    </tr>
    <tr>
      <th scope="row">Сложность операций</th>
      <td colspan="3">O(1) (кроме pop и push в priority_queue)</td>
    </tr>
  </tbody>
</table>

#### **7. Best Practices**
1. **Выбор адаптера**:
    - Используйте `stack` для LIFO (например, отмена операций).
    - Используйте `queue` для FIFO (например, обработка задач).
    - Используйте `priority_queue` для приоритетных задач (например, планировщик).
2. **Оптимизация**:
    - Для `priority_queue` заранее вызывайте `reserve()`, если известен размер.
3. **Безопасность**:
    - Проверяйте `empty()` перед вызовом `top()` или `pop()`.

**Идеальный ответ:**
_"Адаптеры `stack`, `queue` и `priority_queue` предоставляют специализированные интерфейсы для работы с данными:_
_- **`stack`**: LIFO (последний вошёл — первый вышел)._
_- **`queue`**: FIFO (первый вошёл — первый вышел)._
_- **`priority_queue`**: Элементы обрабатываются по приоритету (по умолчанию — от большего к меньшему)._
_Они упрощают работу с классическими структурами данных."_