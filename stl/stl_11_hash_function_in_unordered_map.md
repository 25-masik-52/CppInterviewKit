#### **1. Определение**
Хеш-функция в `std::unordered_map` — это механизм, преобразующий ключ любого типа в числовое значение (`size_t`), которое определяет позицию элемента в хеш-таблице. Это обеспечивает среднюю сложность операций **O(1)** для вставки, удаления и поиска.

#### **2. Основные принципы работы**  
##### **1. Требования к хеш-функции**  
- **Консистентность**: Если `a == b`, то `hash(a) == hash(b)`.  
- **Эффективность**: Вычисление должно занимать **O(1)**.  
- **Равномерность**: Вероятность попадания в любой бакет должна быть одинаковой.  
##### **2. Процесс хеширования**  
1. Ключ преобразуется в `size_t` с помощью хеш-функции.  
2. Индекс бакета вычисляется как:  
   ```cpp
   index = hash(key) % bucket_count();
   ```
   или (если `bucket_count()` — степень двойки):  
   ```cpp
   index = hash(key) & (bucket_count() - 1);
   ```
##### **3. Разрешение коллизий**  
- **Метод цепочек**: Каждый бакет содержит список элементов с одинаковым хешем.  
- В современных реализациях C++ могут использоваться **бинарные деревья** для уменьшения времени поиска при коллизиях.  

#### **3. Стандартные и пользовательские хеш-функции**  
##### **1. Встроенные типы**  
Для стандартных типов (`int`, `std::string` и др.) хеш-функции уже определены в `<functional>`:  
```cpp
std::hash<int> hasher;
size_t hash_value = hasher(42);  // Хеш для числа 42
```
##### **2. Пользовательские типы**  
Для использования пользовательского типа в качестве ключа необходимо:  
1. Определить `operator==`.  
2. Реализовать хеш-функцию (через специализацию `std::hash` или кастомный функтор).
**Пример**:  
```cpp
struct Point {
    int x, y;
    bool operator==(const Point& p) const { return x == p.x && y == p.y; }
};

// Способ 1: Специализация std::hash
namespace std {
    template<>
    struct hash<Point> {
        size_t operator()(const Point& p) const {
            return hash<int>()(p.x) ^ (hash<int>()(p.y) << 1);
        }
    };
}

// Способ 2: Кастомный функтор
struct PointHasher {
    size_t operator()(const Point& p) const {
        return hash<int>()(p.x) ^ hash<int>()(p.y);
    }
};

std::unordered_map<Point, std::string, PointHasher> my_map;
```
**Важно**:  
- Хеш-функция должна минимизировать коллизии.  
- Комбинируйте хеши полей с помощью XOR (`^`) или сдвигов (`<<`, `>>`).  

#### **4. Рехеширование (Rehashing)**  
##### **1. Автоматическое рехеширование**  
Происходит, когда `load_factor()` (среднее число элементов на бакет) превышает `max_load_factor()` (по умолчанию `1.0`).  
- Увеличивает `bucket_count()`.  
- Перераспределяет элементы по новым бакетам.  
- **Инвалидирует все итераторы** (но не ссылки/указатели на элементы).  
##### **2. Управление рехешированием**  
- **`reserve(n)`**: Резервирует память для `n` элементов.  
- **`rehash(n)`**: Устанавливает количество бакетов в `n`.  
**Пример**:  
```cpp
std::unordered_map<int, int> map;
map.reserve(100);  // Избегает частых рехеширований
```

#### **5. Проблемы и оптимизации**  
##### **1. Коллизии**  
- **Плохая хеш-функция**:  
  ```cpp
  struct BadHasher {
      size_t operator()(int key) const { return 42; }  // Все ключи в один бакет!
  };
  ```
  **Последствия**: Деградация до **O(n)** для операций.  
- **Решение**:  
  Используйте криптографические хеш-функции (`MurmurHash`, `CityHash`) или комбинируйте хеши полей.  
##### **2. Производительность**  
- **Локальность данных**: `std::unordered_map` может уступать `std::map` на маленьких данных из-за промахов кэша.  
- **Оптимизация**:  
  - Заранее вызывайте `reserve()`.  
  - Выбирайте `max_load_factor` (например, `0.75` для баланса скорости/памяти).  

#### **6. Пример: Влияние хеш-функции**  

```cpp
#include <unordered_map>
#include <iostream>

struct GoodHasher {
    size_t operator()(int key) const { return std::hash<int>()(key); }
};

int main() {
    std::unordered_map<int, std::string, GoodHasher> map;
    map.reserve(1000);

    for (int i = 0; i < 1000; ++i) {
        map[i] = "value";
    }

    std::cout << "Bucket count: " << map.bucket_count() 
              << ", Load factor: " << map.load_factor() << "\n";
}
```
**Вывод**:  
```
Bucket count: 1031, Load factor: 0.969932
```

**Идеальный ответ:**
_"Хеш-функция в `unordered_map` преобразует ключ в числовой индекс, определяющий позицию элемента в хеш-таблице. Она должна быть быстрой, консистентной и равномерной, чтобы минимизировать коллизии. Для пользовательских типов требуется определить `operator==` и специализировать `std::hash` (или передать свою функцию). Качество хеш-функции напрямую влияет на производительность: плохая функция приводит к кластеризации, а хорошая обеспечивает среднюю сложность O(1). Управлять поведением хеш-таблицы можно через `reserve()` и `rehash()`, но помните — рехеширование инвалидирует итераторы. В итоге, `unordered_map` сочетает скорость доступа с гибкостью, но требует внимания к выбору хеш-функции и настройке параметров."_