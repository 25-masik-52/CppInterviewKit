#### **1. Определение задачи**  
Необходимо найти элемент с порядковым номером `k` в отсортированной последовательности узлов бинарного дерева поиска (BST), используя **итеративный подход** (без рекурсии).

#### **2. Ключевая идея**  
- **In-order обход BST** возвращает узлы в отсортированном порядке.  
- **k-й посещённый узел** в этом обходе — искомый элемент.  
- Для итеративной реализации используется **стек** (LIFO), который имитирует рекурсивные вызовы.

#### **3. Алгоритм**  

1. **Инициализация:**  
   - Стек для хранения узлов.  
   - Указатель `current` на корень дерева.  
   - Счётчик `count = 0` для отслеживания порядка элементов.  

2. **Проход вглубь по левым узлам:**  
   - Пока `current` не `nullptr`, добавляем узел в стек и переходим к `current->left`.  

3. **Извлечение и проверка:**  
   - Извлекаем узел из стека — это следующий элемент в in-order.  
   - Увеличиваем `count`. Если `count == k`, возвращаем значение узла.  
   - Переходим к правому поддереву (`current = node->right`).  

4. **Завершение:**  
   - Если дерево пройдено, а `count < k`, возвращаем ошибку (k превышает размер дерева).  

#### **4. Реализация на C++**  

```cpp
#include <stack>

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

int kthSmallest(TreeNode* root, int k) {
    std::stack<TreeNode*> stack;
    TreeNode* current = root;
    int count = 0;
    
    while (current || !stack.empty()) {
        // Доходим до самого левого узла
        while (current) {
            stack.push(current);
            current = current->left;
        }
        
        // Извлекаем и проверяем
        current = stack.top();
        stack.pop();
        count++;
        
        if (count == k) {
            return current->val;
        }
        
        // Переходим к правому поддереву
        current = current->right;
    }
    
    return -1; // Если k больше размера дерева
}
```
**Пример вызова:**
```cpp
TreeNode* root = new TreeNode(5);
root->left = new TreeNode(3);
root->right = new TreeNode(6);
root->left->left = new TreeNode(2);
root->left->right = new TreeNode(4);

int k = 3;
cout << kthSmallest(root, k);  // Вывод: 4
```

#### **5. Пример работы**  

**Дерево:**  
```
      5
     / \
    3   6
   / \
  2   4
```
**Поиск 3-го наименьшего элемента:**  
1. Стек: `[5, 3, 2]` → извлекаем 2 (`count=1`).  
2. Стек: `[5, 3]` → извлекаем 3 (`count=2`).  
3. Переход к правому поддереву 3 (узел 4).  
4. Стек: `[5, 4]` → извлекаем 4 (`count=3`).  
**Результат:** `4`.  

#### **6. Сложность**  

| Параметр       | Значение                          | Объяснение                          |
|----------------|----------------------------------|-------------------------------------|
| **Время**      | `O(H + k)`                       | `H` — высота дерева. В сбалансированном дереве: `O(log n + k)`. |
| **Память**     | `O(H)`                           | Затраты на стек (максимальная глубина).          |

**Примечание:**  
- Для вырожденного дерева (списка) сложность времени — `O(n)`, памяти — `O(n)`.  

#### **7. Оптимизации**  

1. **Кеширование in-order обхода**  
   - Однократно сохранить элементы в массив → последующие запросы за `O(1)`.  
   - **Память:** `O(n)`.  

2. **Модификация структуры узла**  
   - Добавить поле `size` (количество узлов в поддереве).  
   - Поиск за `O(log n)` без полного обхода.  
   ```cpp
   struct TreeNode {
       int val;
       int size; // Количество узлов в поддереве
       TreeNode* left;
       TreeNode* right;
   };
   ```

#### **8. Сравнение методов**  

| Метод               | Время       | Память    | Примечание                          |
|---------------------|------------|----------|-------------------------------------|
| **Итеративный in-order** | `O(H + k)` | `O(H)`   | Оптимален для единичных запросов.    |
| **Кеширование**     | `O(1)`     | `O(n)`   | Для частых запросов.                |
| **Размер поддерева**| `O(log n)` | `O(1)`   | Требует модификации структуры.      |

**Идеальный ответ:**  
*Для поиска k-го наименьшего элемента в BST без рекурсии:*
*1. Используйте **итеративный in-order обход** со стеком.*
*2. Алгоритм:*
	*- Проходим до крайнего левого узла, сохраняя путь в стек.*
	*- Извлекаем узлы из стека, увеличивая счётчик. При `count == k` возвращаем значение.*
*3. **Сложность:** `O(H + k)` времени, `O(H)` памяти.*
*4. **Оптимизации:** Кеширование или хранение размера поддерева в узлах.*

