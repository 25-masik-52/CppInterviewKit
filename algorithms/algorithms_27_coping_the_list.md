#### **1. Определение**  
Задача требует создать **глубокую копию** связного списка, где каждый узел содержит:  
- `val` — значение узла,  
- `next` — указатель на следующий узел,  
- `random` — произвольный указатель на другой узел или `nullptr`.  

#### **2. Основные понятия**  
- **Глубокая копия:** Все узлы и указатели (`next`, `random`) должны быть новыми, а не ссылаться на оригинальные.  
- **Сложность:** Оптимальное решение — `O(n)` по времени и памяти.  

#### **3. Реализация на C++ (с использованием хеш-таблицы)**  

**Шаги алгоритма:**  
1. **Создание копий узлов** и сохранение соответствия оригинал ↔ копия в `unordered_map`.  
2. **Копирование указателей** `next` и `random` для новых узлов.  
3. **Возврат головы** скопированного списка.  

**Полный код:**  
```cpp
#include <unordered_map>

class Node {
public:
    int val;
    Node* next;
    Node* random;
    Node(int _val) : val(_val), next(nullptr), random(nullptr) {}
};

Node* copyRandomList(Node* head) {
    if (!head) return nullptr;

    std::unordered_map<Node*, Node*> nodeMap;
    Node* current = head;

    // Шаг 1: Создаем копии узлов
    while (current) {
        nodeMap[current] = new Node(current->val);
        current = current->next;
    }

    // Шаг 2: Копируем указатели next и random
    current = head;
    while (current) {
        Node* copy = nodeMap[current];
        copy->next = nodeMap[current->next];
        copy->random = nodeMap[current->random];
        current = current->next;
    }

    // Шаг 3: Возвращаем голову копии
    return nodeMap[head];
}
```

#### **4. Применение и примеры**  
- **Пример списка:**  
  ```
  Оригинал: A (random → C) → B (random → A) → C (random → nullptr)
  Копия:   A' (random → C') → B' (random → A') → C' (random → nullptr)
  ```
- **Где используется:**  
  - Клонирование сложных структур данных (например, графов с циклами).  
  - Реализация функциональности "глубокого копирования" в библиотеках.  

#### **5. Плюсы и минусы**  
- **Плюсы:**  
  - Простота и читаемость кода.  
  - Гарантированная корректность копирования (`random` указатели обрабатываются правильно).  
- **Минусы:**  
  - Дополнительная память `O(n)` для хранения `nodeMap`.  

#### **6. Сравнение с другими подходами**  
| **Метод**                | **Память** | **Время** | **Особенности**                                    |
| ------------------------ | ---------- | --------- | -------------------------------------------------- |
| **С хеш-таблицей**       | `O(n)`     | `O(n)`    | Простота, надежность.                              |
| **Без доппамяти (O(1))** | `O(1)`     | `O(n)`    | Сложнее в реализации (вставка копий между узлами). |

#### **7. Best Practices**  
- **Оптимизации:**  
  - Использование `unordered_map` для константного времени доступа.  
  - Проверка на `nullptr` при обработке `random` указателей.  
- **Ошибки:**  
  - Пропуск инициализации `random` (может привести к неопределённому поведению).  

**Идеальный ответ:**
_Для копирования списка с `random` указателями за `O(n)` времени и памяти:_
_1. Создайте копии всех узлов, сохранив соответствие оригинал ↔ копия в `unordered_map`._
_2. Скопируйте указатели `next` и `random`, используя созданные соответствия._
_3. Верните голову нового списка._
_**Пример вызова:**_
```cpp
Node* copiedList = copyRandomList(originalHead);
```
_**Альтернатива с `O(1)` памятью:** Встраивание копий между узлами оригинала, но метод сложнее и менее нагляден. Используйте хеш-таблицу, если нет жестких ограничений на память._