#### **1. Определение**  
**Сложность алгоритма** — это оценка времени выполнения или потребления памяти в зависимости от размера входных данных (`n`). Измеряется с помощью **О-нотации (Big-O).**

#### **2. Основные понятия**  
- **O-нотация** описывает **верхнюю границу** роста ресурсов алгоритма.  
- **Упрощение**:  
  - Отбрасываются константы (например, `O(2n)` → `O(n)`).  
  - Оставляется самый быстрорастущий член (например, `O(n² + n)` → `O(n²)`).  

#### **3. Виды сложности и примеры**  

1. **O(1) — Константная сложность**  
- **Описание**: Время не зависит от `n`.  
- **Примеры**:  
  - Доступ к элементу массива по индексу.  
  - Вставка в начало связного списка (если есть указатель на голову).  
```cpp
int getFirstElement(int arr[]) {
    return arr[0];  // O(1) — всегда одна операция
}
```

2. **O(log n) — Логарифмическая сложность**  
- **Описание**: Время растёт пропорционально `log n` (деление задачи пополам).  
- **Примеры**:  
  - Бинарный поиск в отсортированном массиве.  
  - Поиск в бинарном дереве поиска.  
```cpp
int binarySearch(int arr[], int n, int target) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;  // O(log n) — уменьшает диапазон в 2 раза
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

3. **O(n) — Линейная сложность**  
- **Описание**: Время прямо пропорционально `n`.  
- **Примеры**:  
  - Поиск максимума в неотсортированном массиве.  
  - Обход связного списка.  
```cpp
int findMax(int arr[], int n) {
    int max = arr[0];
    for (int i = 1; i < n; ++i) {  // O(n) — проходит все элементы
        if (arr[i] > max) max = arr[i];
    }
    return max;
}
```

4. **O(n²) — Квадратичная сложность**  
- **Описание**: Время пропорционально квадрату `n` (вложенные циклы).  
- **Примеры**:  
  - Пузырьковая сортировка.  
  - Сортировка выбором.  
```cpp
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; ++i) {          // O(n)
        for (int j = 0; j < n-i-1; ++j) {    // O(n) → O(n²)
            if (arr[j] > arr[j+1]) {
                std::swap(arr[j], arr[j+1]);
            }
        }
    }
}
```

#### **4. Применение и примеры**  
- **O(1)**: Кеширование, хеш-таблицы.  
- **O(log n)**: Алгоритмы на деревьях (AVL, B-деревья).  
- **O(n²)**: Простые сортировки для малых данных (например, `Insertion Sort` для `n < 10`).  

#### **5. Плюсы и минусы**  
| Сложность    | Плюсы                          | Минусы                                                     |
| ------------ | ------------------------------ | ---------------------------------------------------------- |
| **O(1)**     | Мгновенное выполнение.         | Редко применима для сложных задач.                         |
| **O(log n)** | Эффективна для больших данных. | Требует предварительной сортировки (для бинарного поиска). |
| **O(n²)**    | Простота реализации.           | Неэффективна для больших `n`.                              |

#### **6. Сравнение с другими подходами**  
- **O(n log n)** (MergeSort, QuickSort) vs **O(n²)** (BubbleSort):  
  - Для `n = 1000`: `1000 * log(1000) ≈ 10,000` vs `1,000,000` операций.  

#### **7. Best Practices**  
1. **Избегайте O(n²)** для больших данных.  
2. **Используйте O(log n)** для поиска (бинарный поиск, деревья).  
3. **Оптимизируйте вложенные циклы** (кеширование, мемоизация).  

**Пример оптимизации**:  
```cpp
// Было: O(n²)  
for (int i = 0; i < n; ++i) {
    for (int j = 0; j < n; ++j) { ... }
}

// Стало: O(n) с хеш-таблицей  
std::unordered_map<int, int> cache;
for (int i = 0; i < n; ++i) { ... }  // Поиск за O(1)
```

**Идеальный ответ:**  
_Сложность алгоритма оценивает рост времени/памяти от размера входных данных (`n`). **O(1)** — константное время (доступ по индексу), **O(log n)** — логарифмическое (бинарный поиск), **O(n²)** — квадратичное (пузырьковая сортировка). Для больших данных предпочтительны алгоритмы с **O(n log n)** или лучше. Оптимизация сложности — ключ к эффективному коду.
Пример выбора:_
_- Для поиска: **бинарный поиск (O(log n))** вместо линейного (O(n))._
_- Для сортировки: **QuickSort (O(n log n))** вместо BubbleSort (O(n²))._