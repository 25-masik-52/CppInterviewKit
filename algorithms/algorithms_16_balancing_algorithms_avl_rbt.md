#### **1. Определение и необходимость балансировки**  
**Бинарные деревья поиска (BST)** могут вырождаться в связный список при неудачной последовательности операций, что увеличивает сложность с `O(log n)` до `O(n)`.  
**Балансировка** поддерживает высоту дерева близкой к `log n`, обеспечивая эффективность операций.

#### **2. AVL-деревья**  

##### **2.1. Основные свойства**  
- **Баланс-фактор**: Разница высот поддеревьев каждого узла ∈ `{-1, 0, 1}`.  
- **Гарантированная высота**: `~1.44 log₂n`.  

##### **2.2. Типы поворотов**  
1. **Левый поворот**:  
   - Применяется, когда правое поддерево перевешивает (`balance < -1`).  
   ```cpp
   Node* leftRotate(Node* a) {
       Node* b = a->right;
       a->right = b->left;
       b->left = a;
       return b;
   }
   ```  
2. **Правый поворот**:  
   - Левое поддерево перевешивает (`balance > 1`).  
3. **Лево-правый и право-левый повороты**:  
   - Комбинации для сложных случаев.  

##### **2.3. Плюсы и минусы**  
- ✅ **Быстрый поиск** (идеально для read-heavy нагрузок).  
- ❌ **Частые перебалансировки** (медленнее вставка/удаление).  

**Пример AVL-дерева**:  
```
      4
    /   \
   2     5
  / \
 1   3
```

#### **3. Красно-чёрные деревья**  

##### **3.1. Основные свойства**  
1. Узлы — **красные** или **чёрные**.  
2. Корень и листья (`nullptr`) — чёрные.  
3. **Нет двух красных узлов подряд**.  
4. Все пути от узла к листьям содержат одинаковое число чёрных узлов.  

##### **3.2. Балансировка**  
- **Перекрашивание** и **повороты** (реже, чем в AVL).  
- **Пример вставки**:  
  - Случай 1: Дядя красный → перекрасить родителя и дядю.  
  - Случай 2: Дядя чёрный → поворот.  

**Код (упрощённо)**:  
```cpp
void fixInsertion(Node* node) {
    while (node->parent->color == RED) {
        if (parent == grandparent->left) {
            Node* uncle = grandparent->right;
            if (uncle->color == RED) {  // Случай 1
                parent->color = BLACK;
                uncle->color = BLACK;
                grandparent->color = RED;
                node = grandparent;
            } else {  // Случай 2
                if (node == parent->right) {
                    node = parent;
                    leftRotate(node);
                }
                parent->color = BLACK;
                grandparent->color = RED;
                rightRotate(grandparent);
            }
        }
    }
    root->color = BLACK;
}
```

##### **3.3. Плюсы и минусы**  
- ✅ **Меньше перебалансировок** (быстрее вставка/удаление).  
- ❌ **Высота до ~2 log₂n** (поиск медленнее AVL).  

**Пример красно-чёрного дерева**:  
```
       B (чёрный)
     /   \
    R     R (красные)
   / \   / \
  B  B B   B
```

#### **4. Сравнение AVL и красно-чёрных деревьев**  

| Критерий              | AVL-деревья                 | Красно-чёрные деревья       |
| --------------------- | --------------------------- | --------------------------- |
| **Строгость баланса** | Высота поддеревьев ≤ 1      | Правила окрашивания         |
| **Поиск**             | `O(log n)` (быстрее)        | `O(log n)` (медленнее)      |
| **Вставка/удаление**  | Частые повороты (медленнее) | Реже балансировка (быстрее) |
| **Применение**        | Базы данных (MySQL)         | STL (`std::map`), ОС        |

#### **5. Выбор алгоритма**  
- **Частый поиск?** → AVL.  
- **Частые вставки/удаления?** → Красно-чёрное дерево.  

**Пример в C++ (`std::map`)**:  
```cpp
#include <map>
std::map<int, std::string> rbTree;  // Красно-чёрное дерево
rbTree[5] = "Hello";
```

**Идеальный ответ:**
_**AVL-деревья** обеспечивают строгую балансировку (разница высот ≤ 1), что ускоряет поиск, но требует частых поворотов. **Красно-чёрные деревья** используют правила окрашивания для менее строгой балансировки, что оптимизирует вставку/удаление._
_**Ключевые выводы**:_
*1. **AVL** — для задач с преобладанием поиска (например, БД).*
*2. **Красно-чёрные** — для смешанных операций (STL, ОС).*
*3. **Реализация в C++**: `std::map` использует красно-чёрные деревья.*