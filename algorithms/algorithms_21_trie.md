#### **1. Определение**
**Trie** (от англ. "retrieval" — извлечение) — это древовидная структура данных, которая используется для хранения набора строк. Каждый узел дерева представляет собой символ строки, а путь от корня до узла соответствует префиксу или полной строке.

**Основные характеристики:**
1. **Узлы**: Каждый узел содержит ссылки на дочерние узлы (обычно в виде массива или хеш-таблицы).
2. **Конец строки**: Узел может быть помечен как конец строки (например, флаг `isEndOfWord`).
3. **Префиксы**: Все строки с общим префиксом имеют общий путь от корня.

#### **2. Структура Trie**
**Пример:**
Предположим, мы хотим хранить строки: `"apple"`, `"app"`, `"bat"`, `"bar"`.
Структура Trie будет выглядеть так:
```
        root
       /    \
      a      b
     / \      \
    p   t      a
   /           / \
  p           r   t
 / \
l   e
```
Здесь:
- Путь `a → p → p → l → e` соответствует строке `"apple"`.
- Путь `a → p → p` соответствует строке `"app"`.
- Флаг `isEndOfWord` установлен для узлов, соответствующих концам строк (`"app"`, `"apple"`, `"bat"`, `"bar"`).

#### **3. Основные операции**
1. **Вставка строки**:
   - Начинаем с корня.
   - Для каждого символа строки переходим к соответствующему дочернему узлу. Если узла нет, создаём его.
   - В конце пути устанавливаем флаг `isEndOfWord`.
2. **Поиск строки**:
   - Начинаем с корня.
   - Для каждого символа строки переходим к соответствующему дочернему узлу.
   - Если путь существует и последний узел помечен как `isEndOfWord`, строка найдена.
3. **Поиск префикса**:
   - Аналогично поиску строки, но не проверяем флаг `isEndOfWord`.
4. **Удаление строки**:
   - Находим строку в Trie.
   - Если строка найдена, удаляем её, начиная с конца (если узлы больше не используются).

#### **4. Реализация на C++**
```cpp
#include <iostream>
#include <unordered_map>

class TrieNode {
public:
    std::unordered_map<char, TrieNode*> children;
    bool isEndOfWord;

    TrieNode() : isEndOfWord(false) {}
};

class Trie {
private:
    TrieNode* root;

public:
    Trie() {
        root = new TrieNode();
    }

    // Вставка строки
    void insert(const std::string& word) {
        TrieNode* current = root;
        for (char ch : word) {
            if (current->children.find(ch) == current->children.end()) {
                current->children[ch] = new TrieNode();
            }
            current = current->children[ch];
        }
        current->isEndOfWord = true;
    }

    // Поиск строки
    bool search(const std::string& word) {
        TrieNode* current = root;
        for (char ch : word) {
            if (current->children.find(ch) == current->children.end()) {
                return false;
            }
            current = current->children[ch];
        }
        return current->isEndOfWord;
    }

    // Поиск префикса
    bool startsWith(const std::string& prefix) {
        TrieNode* current = root;
        for (char ch : prefix) {
            if (current->children.find(ch) == current->children.end()) {
                return false;
            }
            current = current->children[ch];
        }
        return true;
    }
};

int main() {
    Trie trie;

    trie.insert("apple");
    trie.insert("app");
    trie.insert("bat");
    trie.insert("bar");

    std::cout << std::boolalpha; // Вывод true/false вместо 1/0
    std::cout << "Search 'apple': " << trie.search("apple") << "\n"; // true
    std::cout << "Search 'app': " << trie.search("app") << "\n";     // true
    std::cout << "Search 'appl': " << trie.search("appl") << "\n";   // false
    std::cout << "Starts with 'app': " << trie.startsWith("app") << "\n"; // true
    std::cout << "Starts with 'ba': " << trie.startsWith("ba") << "\n";   // true

    return 0;
}
```

**Производительность**

| **Операция**         | **Сложность**       |
|----------------------|---------------------|
| Вставка строки       | O(L), где L — длина строки |
| Поиск строки         | O(L)               |
| Поиск префикса       | O(L)               |

#### **5. Где применяется Trie?**
1. **Автозавершение текста**:
   - Например, подсказки при вводе текста в поисковых системах или текстовых редакторах.
2. **Словари и поиск слов**:
   - Хранение словарей для быстрого поиска слов или проверки их существования.
3. **IP-маршрутизация**:
   - Используется в сетевых маршрутизаторах для поиска маршрутов по префиксам IP-адресов.
4. **Подсчёт частоты слов**:
   - Можно использовать Trie для подсчёта, сколько раз каждое слово встречается в тексте.
5. **Поиск шаблонов в строках**:
   - Например, поиск всех слов из словаря, которые являются подстроками заданного текста.
6. **Инвертированные индексы**:
   - В поисковых системах Trie может использоваться для индексации слов.

#### **6. Плюсы и минусы**

**Преимущества Trie**
1. **Быстрый поиск**:
   - Поиск строки или префикса выполняется за O(L), где L — длина строки.
2. **Эффективное использование памяти**:
   - Общие префиксы хранятся только один раз.
3. **Масштабируемость**:
   - Подходит для больших наборов данных.

**Недостатки Trie**
1. **Потребление памяти**:
   - Для больших алфавитов (например, Unicode) Trie может занимать много памяти.
2. **Сложность реализации**:
   - Реализация Trie сложнее, чем простой массив или хеш-таблица.

#### **7. Сравнение с другими структурами**

|**Структура**|**Поиск**|**Вставка**|**Память**|
|---|---|---|---|
|**Trie**|O(L)|O(L)|Высокая|
|**Хеш-таблица**|O(1)|O(1)|Умеренная|
|**Список**|O(n)|O(1)|Низкая|

**Выбор**:
- **Trie** — для задач с префиксами (автодополнение).
- **Хеш-таблица** — для точного поиска (словари).

**Идеальный ответ:**
_**Префиксное дерево (Trie)** — это мощная структура данных для работы со строками, особенно в задачах, связанных с префиксами. Оно широко применяется в автозавершении, словарях, маршрутизации и других областях. Благодаря своей эффективности и гибкости, Trie является незаменимым инструментом для многих задач обработки текста. Оно применяется в автозавершении, словарях, IP-маршрутизации и других задачах, связанных с поиском строк или префиксов. Все операции выполняются за O(L), где L — длина строки._