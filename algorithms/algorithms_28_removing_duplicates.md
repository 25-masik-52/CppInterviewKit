#### **1. Определение**  
Задача требует удалить дубликаты из **несортированного связного списка**, используя **константную память** (`O(1)`), без применения структур данных (например, хеш-таблиц) или сортировки.

#### **2. Основные понятия**  
- **Ограничения:**  
  - Нельзя использовать дополнительные структуры данных (`unordered_set`, массив и т.д.).  
  - Память: только `O(1)` (например, несколько указателей).  
- **Сложность:**  
  - Оптимальное решение без доппамяти — `O(n²)` времени.  

#### **3. Реализация на C++ (метод двойного указателя)**  

**Алгоритм:**  
1. **Внешний цикл (`current`):** Проходит по списку.  
2. **Внутренний цикл (`runner`):** Для каждого `current` проверяет последующие узлы и удаляет дубликаты.  

**Код:**  
```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* removeDuplicates(ListNode* head) {
    if (!head) return nullptr;

    ListNode* current = head;
    while (current) {
        ListNode* runner = current;
        while (runner->next) {
            if (runner->next->val == current->val) {
                ListNode* duplicate = runner->next;
                runner->next = runner->next->next;
                delete duplicate; // Освобождение памяти (опционально)
            } else {
                runner = runner->next;
            }
        }
        current = current->next;
    }
    return head;
}
```

#### **4. Применение и примеры**  
- **Пример списка:**  
  ```
  Исходный: 1 → 2 → 3 → 2 → 1 → 4 → nullptr  
  Результат: 1 → 2 → 3 → 4 → nullptr  
  ```  
- **Шаги работы:**  
  1. Для `current = 1` удаляется второй `1`.  
  2. Для `current = 2` удаляется второй `2`.  
  3. Для `current = 3` и `4` дубликатов нет.  

#### **5. Плюсы и минусы**  
- **Плюсы:**  
  - Константная память (`O(1)`).  
  - Не требует сортировки или дополнительных структур.  
- **Минусы:**  
  - Квадратичное время (`O(n²)`).  

#### **6. Сравнение с другими подходами**  
| **Метод**                 | **Время**    | **Память** | **Условия**                          |
| ------------------------- | ------------ | ---------- | ------------------------------------ |
| **Двойной указатель**     | `O(n²)`      | `O(1)`     | Без доппамяти и сортировки.          |
| **С хеш-таблицей**        | `O(n)`       | `O(n)`     | Требует доппамяти.                   |
| **Сортировка + удаление** | `O(n log n)` | `O(1)`     | Требует изменения порядка элементов. |

#### **7. Best Practices**  
- **Оптимизации:**  
  - Ранний выход, если `head == nullptr`.  
  - Освобождение памяти удаляемых узлов (если требуется).  
- **Ошибки:**  
  - Пропуск проверки `runner->next` во внутреннем цикле (может привести к `nullptr` исключению).  

**Идеальный ответ:**
_Для удаления дубликатов из несортированного списка **без дополнительной памяти** используйте метод двойного указателя:_
_1. Внешний цикл (`current`) проходит по списку._
_2. Внутренний цикл (`runner`) удаляет все последующие узлы с таким же значением, как `current->val`._
_**Сложность:** `O(n²)` времени, `O(1)` памяти._
_**Пример вызова:**_
```cpp
ListNode* newHead = removeDuplicates(head);
```
_**Альтернативы:**_
_- Если допустима сортировка — сначала сортируйте список (`O(n log n)`), затем удаляйте дубликаты за `O(n)`._
_- Если доступна доппамять — используйте `unordered_set` (`O(n)` времени и памяти)._
_**Итог:** Метод двойного указателя — единственное решение при жестких ограничениях на память._