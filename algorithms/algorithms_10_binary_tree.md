#### **1. Определение**  
**Бинарное дерево** — это иерархическая структура данных, где каждый узел имеет **не более двух потомков** (левый и правый).  

#### **2. Структурные свойства**  

**2.1. Узлы и связи**  
- Каждый узел содержит:  
  - **Данные** (значение или объект).  
  - **Указатели** на левого и правого потомка (`left`, `right`).  
  - (Опционально) Указатель на родителя.  

**2.2. Виды бинарных деревьев**

| Тип дерева                  | Описание                                                                 |
|-----------------------------|--------------------------------------------------------------------------|
| **Полное бинарное дерево**  | Все уровни, кроме последнего, полностью заполнены.                      |
| **Сбалансированное дерево** | Глубина поддеревьев отличается не более чем на 1 (например, AVL-дерево). |
| **Вырожденное дерево**      | Каждый узел имеет только одного потомка (аналог связного списка).       |
| **Бинарное дерево поиска (BST)** | Упорядочено: `left < parent < right`.                                  |

**Пример BST**:  
```
      5
     / \
    3   8  
   / \ / \
  1  4 7 9
```

#### **3. Свойства бинарного дерева поиска (BST)**  

**3.1. Упорядоченность**  
- Левые потомки < Текущий узел < Правые потомки.  

**3.2. Сложность операций**

| Операция     | Средний случай (сбалансированное) | Худший случай (вырожденное) |
| ------------ | --------------------------------- | --------------------------- |
| **Поиск**    | $O(log(n))$                       | O(n)                        |
| **Вставка**  | $O(log(n))$                       | O(n)                        |
| **Удаление** | $O(log(n))$                       | O(n)                        |

#### **4. Обход дерева (Traversal)**  

**4.1. In-Order (центрированный)**  
- **Порядок**: Левый → Узел → Правый.  
- **Результат**: Элементы в отсортированном порядке (для BST).  
- **Код**:  
  ```cpp
  void inOrder(Node* node) {
      if (!node) return;
      inOrder(node->left);
      std::cout << node->data << " ";
      inOrder(node->right);
  }
  ```
  **Вывод**: `1 3 4 5 7 8 9`.

**4.2. Pre-Order (прямой)**  
- **Порядок**: Узел → Левый → Правый.  
- **Применение**: Копирование структуры дерева.  
- **Код**:  
  ```cpp
  void preOrder(Node* node) {
      if (!node) return;
      std::cout << node->data << " ";
      preOrder(node->left);
      preOrder(node->right);
  }
  ```
  **Вывод**: `5 3 1 4 8 7 9`.

**4.3. Post-Order (обратный)**  
- **Порядок**: Левый → Правый → Узел.  
- **Применение**: Удаление дерева.  
- **Код**:  
  ```cpp
  void postOrder(Node* node) {
      if (!node) return;
      postOrder(node->left);
      postOrder(node->right);
      std::cout << node->data << " ";
  }
  ```
  **Вывод**: `1 4 3 7 9 8 5`.

#### **5. Балансировка дерева**  
- **Проблема**: Вырожденные деревья ухудшают сложность до O(n).  
- **Решение**:  
  - **AVL-деревья**: Балансировка через повороты.  
  - **Красно-чёрные деревья**: Используются в `std::map` и `std::set`.  

**Пример AVL-балансировки**:  
```
Несбалансированное:   Сбалансированное:
        5                    4
       /                    / \
      4                    3   5
     /
    3
```

#### **6. Применение**  
- **BST**: Словари, базы данных.  
- **Двоичные кучи**: Приоритетные очереди (`std::priority_queue`).  
- **Деревья выражений**: Вычисление арифметических выражений.  

#### **7. Реализация узла на C++**  
```cpp
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};
```

**Идеальный ответ:**  
*Бинарное дерево — структура с двумя потомками на узел. **BST** обеспечивает быстрый поиск (O(log n)), но требует балансировки. Основные обходы:  
*- **In-Order** для сортировки,*
*- **Pre-Order** для копирования,*
*- **Post-Order** для удаления.*
*Балансировка (AVL, красно-чёрные деревья) критична для избежания O(n). Применяется в словарях, очередях с приоритетом и др.*