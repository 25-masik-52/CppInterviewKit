#### **1. Определение**
**Адаптер** — это структурный паттерн, который позволяет **совмещать несовместимые интерфейсы**, преобразуя интерфейс одного класса в интерфейс, ожидаемый клиентом. Действует как "переводчик" между двумя объектами.

#### **2. Когда использовать?**
- Интеграция **устаревшего кода** с новой системой
- Работа с **внешними API**, имеющими несовместимый интерфейс
- Унификация **разнородных интерфейсов** для единой работы

#### **3. Типы реализации**

**1. Адаптер на классах (Class Adapter)**
Использует множественное наследование.

```cpp
// Целевой интерфейс (клиент ожидает этот интерфейс)
class Target {
public:
    virtual void request() = 0;
};

// Адаптируемый класс (старая система)
class Adaptee {
public:
    void specificRequest() {
        std::cout << "Вызов специфического метода\n";
    }
};

// Адаптер (наследует оба класса)
class Adapter : public Target, private Adaptee {
public:
    void request() override {
        specificRequest(); // Преобразование вызова
    }
};
```

**2. Адаптер на объектах (Object Adapter)**
Использует композицию (более гибкий вариант).

```cpp
class Adapter : public Target {
private:
    Adaptee* adaptee; // Композиция
public:
    Adapter(Adaptee* a) : adaptee(a) {}
    void request() override {
        adaptee->specificRequest();
    }
};
```

#### **4. Различия между типами**

| Критерий          | Class Adapter               | Object Adapter             |
|--------------------|-----------------------------|----------------------------|
| **Связность**      | Жесткая (наследование)      | Гибкая (композиция)        |
| **Множественные адаптации** | Нет                       | Да                         |
| **Изменение поведения** | Требует переопределения | Можно динамически менять   |

#### **5. Плюсы и минусы**

**Преимущества:**
- Позволяет **интегрировать старый код без изменений**
- **Изолирует** клиентский код от несовместимых интерфейсов
- **Гибкость** при работе с разными версиями API

**Недостатки:**
- Увеличивает **количество классов** в системе
- Может **маскировать проблемы** архитектуры

#### **6. Реальные примеры**
1. **Работа с разными API платежных систем**  
   ```cpp
   class PayPalAdapter : public PaymentGateway {
   private:
       PayPalAPI paypal;
   public:
       void processPayment(double amount) override {
           paypal.sendPayment(amount);
       }
   };
   ```

2. **Адаптация форматов данных**  
   ```cpp
   class XMLtoJSONAdapter : public JSONService {
   private:
       XMLService xmlService;
   public:
       std::string getJSON() override {
           auto xml = xmlService.getXML();
           return convertXMLtoJSON(xml);
       }
   };
   ```

#### **7. Сравнение с другими паттернами**

| Паттерн       | Отличие от Adapter          |
|---------------|-----------------------------|
| **Мост**      | Разделяет абстракцию и реализацию заранее |
| **Декоратор** | Добавляет новую функциональность |
| **Фасад**     | Упрощает сложный интерфейс, но не преобразует его |

#### **8. Best Practices**
1. Используйте **Object Adapter** по умолчанию — он более гибкий
2. Избегайте **избыточных адаптеров** — иногда лучше рефакторить код
3. Применяйте для **интеграции сторонних библиотек**

**Идеальный ответ:**  
*"Паттерн Адаптер позволяет совместно работать классам с несовместимыми интерфейсами через преобразование вызовов. Реализуется двумя способами: Class Adapter (через множественное наследование) и Object Adapter (через композицию). Основные сценарии использования: интеграция устаревшего кода, работа с внешними API, унификация интерфейсов. Преимущества: сохранение существующего кода, гибкость. Недостатки: усложнение структуры. В отличие от Моста или Декоратора, Адаптер именно преобразует интерфейсы, а не добавляет новую функциональность."*