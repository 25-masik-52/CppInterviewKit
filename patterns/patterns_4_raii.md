#### 1. **Определение**  
**RAII (Resource Acquisition Is Initialization)** — это ключевая идиома C++, связывающая жизненный цикл ресурса (память, файлы, мьютексы) с временем жизни объекта. Ресурс захватывается в конструкторе и гарантированно освобождается в деструкторе.  

#### 2. **Код-пример**  
```cpp  
class FileRAII {  
    FILE* file_;  
public:  
    FileRAII(const std::string& path) : file_(fopen(path.c_str(), "r")) {  
        if (!file_) throw std::runtime_error("File open error");  
    }  
    ~FileRAII() {  
        if (file_) fclose(file_);  
    }  
    // Запрет копирования (для уникальности ресурса)  
    FileRAII(const FileRAII&) = delete;  
    FileRAII& operator=(const FileRAII&) = delete;  
};  

void example() {  
    FileRAII file("data.txt"); // Ресурс захвачен  
    // ... работа с файлом  
} // Ресурс освобождён автоматически  
```  

#### 3. **Как работает**  
- **Конструктор**: Выделяет ресурс (открытие файла, выделение памяти).  
- **Деструктор**: Освобождает ресурс (закрытие файла, удаление памяти).  
- **Гарантии**: Даже при исключениях деструктор вызывается (благодаря раскрутке стека).

#### 4. **Плюсы RAII**  
- **Безопасность**: Нет утечек ресурсов.  
- **Читаемость**: Код управления ресурсом локализован в одном классе.  
- **Производительность**: Эффективнее ручного управления и сборщика мусора.  

#### 5. **Когда использовать?**  
- Работа с динамической памятью (`std::unique_ptr`, `std::shared_ptr`).  
- Управление файлами, сокетами, мьютексами (`std::lock_guard`).  
- Транзакции (коммит/откат при разрушении объекта).  

#### 6. **Проблемы и решения**  
- **Проблема 1**: Нарушение правила "один ресурс — один класс".  
  **Решение**: Разделять классы (например, `FileRAII` и `MemoryRAII`).  
- **Проблема 2**: Исключения в конструкторе.  
  **Решение**: Использовать умные указатели или вложенные RAII-объекты.  

#### 7. **Альтернативы**  
- **GC-языки** (Java, C#): Управление памятью через сборщик мусора (менее предсказуемо).  
- **Ручное управление** (C, низкоуровневый код): Риск утечек и ошибок.  

**Идеальный ответ:**  
*"RAII — это идиома C++, при которой ресурс захватывается в конструкторе объекта и освобождается в его деструкторе. Это гарантирует безопасность (даже при исключениях), читаемость и производительность. Примеры: умные указатели (`std::unique_ptr`), `std::lock_guard`. Ключевое правило: один класс — один ресурс. Нарушение RAII ведёт к утечкам, поэтому в C++ предпочтительно использовать его вместо ручного управления ресурсами."*  