#### **1. Определение**
**Мост (Bridge)** — это структурный паттерн, который разделяет абстракцию и реализацию на две отдельные иерархии классов, позволяя им изменяться независимо друг от друга.

**Ключевая идея**:
> *"Разделяй абстракцию и реализацию, чтобы избежать монолитных иерархий классов"*

#### **2. Проблема без Bridge**
Представьте систему с:
- 3 типами фигур (Круг, Квадрат, Треугольник)
- 4 цветами (Красный, Синий, Зеленый, Желтый)

Без Bridge потребуется **3 × 4 = 12 классов**:
```
RedCircle, BlueCircle, GreenCircle...
RedSquare, BlueSquare...
```

#### **3. Реализация на C++**

**1. Реализация (цвета)**
```cpp
class Color {
public:
    virtual ~Color() = default;
    virtual std::string apply() const = 0;
};

class Red : public Color {
public:
    std::string apply() const override { return "Красный"; }
};

class Blue : public Color {
public:
    std::string apply() const override { return "Синий"; }
};
```

**2. Абстракция (фигуры)**
```cpp
class Shape {
protected:
    Color* color_;
public:
    Shape(Color* color) : color_(color) {}
    virtual ~Shape() = default;
    virtual void draw() const = 0;
};

class Circle : public Shape {
public:
    Circle(Color* color) : Shape(color) {}
    void draw() const override {
        std::cout << "Рисуем круг цветом " << color_->apply() << "\n";
    }
};

class Square : public Shape {
public:
    Square(Color* color) : Shape(color) {}
    void draw() const override {
        std::cout << "Рисуем квадрат цветом " << color_->apply() << "\n";
    }
};
```

**3. Использование**
```cpp
int main() {
    Red red;
    Blue blue;

    Circle redCircle(&red);
    Square blueSquare(&blue);

    redCircle.draw(); // Рисуем круг цветом Красный
    blueSquare.draw(); // Рисуем квадрат цветом Синий
}
```

#### **4. Плюсы и минусы**

| **Преимущества**                      | **Недостатки**                       |
| ------------------------------------- | ------------------------------------ |
| ✅ Уменьшает количество классов        | ❌ Увеличивает сложность кода         |
| ✅ Позволяет менять реализацию на лету | ❌ Требует тщательного проектирования |
| ✅ Соответствует Open/Closed Principle |                                      |

#### **5. Когда использовать?**
- Когда нужно **разделить монолитную иерархию** классов
- Если реализация должна **изменяться во время выполнения**
- Для поддержки **кросс-платформенных** приложений

#### **6. Отличие от других паттернов**
| **Паттерн** | **Отличие** |
|------------|------------|
| **Адаптер** | Связывает несовместимые интерфейсы |
| **Стратегия** | Меняет поведение, а не всю реализацию |
| **Фасад** | Упрощает сложную систему |

#### **7. Реальные примеры**
1. **Графические API**:
```cpp
class Renderer { /* Vulkan/OpenGL/DirectX */ };
class GameEntity {
    Renderer* renderer_;
public:
    void draw() { renderer_->render(this); }
};
```

2. **Драйверы устройств**:
```cpp
class DeviceDriver { /* USB/Bluetooth */ };
class Peripheral {
    DeviceDriver* driver_;
};
```

**Идеальный ответ**:
*"Паттерн Мост разделяет абстракцию и реализацию на независимые иерархии классов. Он полезен, когда нужно избежать взрывного роста классов (например, фигуры × цвета) и позволить компонентам развиваться независимо. Реализуется через: 1) интерфейс Implementor (цвета), 2) абстракцию Shape (фигуры), где абстракция содержит ссылку на реализацию. Преимущества: гибкость, соответствие OCP. Недостатки: начальная сложность проектирования."*