#### **1. Определение**  
**Паттерн Шаблонный метод (Template Method)** — это поведенческий паттерн, который определяет скелет алгоритма в базовом классе, оставляя подклассам возможность переопределять отдельные шаги, не изменяя структуру алгоритма.  

#### **2. Код-пример**  
**Пример: Генерация отчётов (PDF vs HTML)**  
```cpp
#include <iostream>
#include <string>

// Абстрактный класс с шаблонным методом
class ReportGenerator {
public:
    // Шаблонный метод (фиксированная последовательность)
    void generateReport() final {
        collectData();
        formatData();
        exportReport();
        if (needNotification()) {
            sendNotification();
        }
    }

    virtual ~ReportGenerator() = default;

protected:
    // Обязательные для реализации шаги
    virtual void collectData() = 0;
    virtual void formatData() = 0;
    virtual void exportReport() = 0;

    // Хук (необязательный шаг)
    virtual bool needNotification() const { return false; }
    virtual void sendNotification() { std::cout << "Отправка уведомления...\n"; }
};

// Конкретные реализации
class PDFReport : public ReportGenerator {
protected:
    void collectData() override {
        std::cout << "Сбор данных для PDF...\n";
    }
    void formatData() override {
        std::cout << "Форматирование в PDF...\n";
    }
    void exportReport() override {
        std::cout << "Экспорт PDF-отчёта.\n";
    }
};

class HTMLReport : public ReportGenerator {
protected:
    void collectData() override {
        std::cout << "Сбор данных для HTML...\n";
    }
    void formatData() override {
        std::cout << "Форматирование в HTML...\n";
    }
    void exportReport() override {
        std::cout << "Экспорт HTML-отчёта.\n";
    }
    bool needNotification() const override { return true; }
};

int main() {
    ReportGenerator* pdf = new PDFReport();
    pdf->generateReport();
    delete pdf;

    ReportGenerator* html = new HTMLReport();
    html->generateReport();
    delete html;
}
```
**Вывод:**  
```
Сбор данных для PDF...  
Форматирование в PDF...  
Экспорт PDF-отчёта.  

Сбор данных для HTML...  
Форматирование в HTML...  
Экспорт HTML-отчёта.  
Отправка уведомления...  
```

#### **3. Компоненты и связи**  
- **Abstract Class (ReportGenerator)**  
  Определяет шаблонный метод (`generateReport`) и абстрактные шаги (`collectData`, `formatData`).  
- **Concrete Class (PDFReport, HTMLReport)**  
  Реализует специфичные шаги алгоритма.  
- **Хуки** (`needNotification`)  
  Необязательные методы для расширения логики.  

#### **4. Плюсы паттерна**  
- **Исключает дублирование кода**: Общая логика в базовом классе.  
- **Контроль структуры**: Базовый класс управляет последовательностью шагов.  
- **Гибкость**: Подклассы меняют только необходимые шаги.  

#### **5. Когда использовать?**  
- Когда несколько классов реализуют схожий алгоритм с небольшими различиями.  
- Для фиксации порядка выполнения шагов.  
- Когда часть логики универсальна, а часть — вариативна.  

#### **6. Подводные камни и решения**  
**Минусы:**  
- **Жёсткая структура**: Невозможно изменить порядок шагов в подклассах.  
- **Сложность иерархии**: Много уровней наследования для сложных алгоритмов.  

**Способы решения:**  
- Использовать **стратегии** для вариативных шагов.  
- Применять **хуки** для необязательных расширений.  

#### **7. Альтернативы и отличия от других паттернов**  

| **Паттерн**         | **Отличие от Template Method**               |
| ------------------- | -------------------------------------------- |
| **Стратегия**       | Заменяет весь алгоритм, а не отдельные шаги. |
| **Фабричный метод** | Создаёт объекты, а не определяет алгоритм.   |

#### **8. Примеры в реальных проектах**  
- **Компиляторы**: Фиксированный pipeline (лексический анализ → парсинг → генерация кода).  
- **Фреймворки**: Жизненный цикл обработки HTTP-запроса (middleware → контроллер → ответ).  
- **Игры**: AI-поведение (инициализация → обновление → рендеринг).  

**Идеальный ответ:**  
*"Паттерн Template Method определяет каркас алгоритма в базовом классе, позволяя подклассам переопределять отдельные шаги. Состоит из: 1) абстрактного класса с шаблонным методом, 2) конкретных реализаций. Пример — генерация отчётов в разных форматах. Плюсы: устранение дублирования кода и контроль структуры. Минусы: жёсткость последовательности шагов. Отличается от Стратегии (замена всего алгоритма) и Фабричного метода (создание объектов)."*