#### **1. Определение**  
**Паттерн Заместитель (Proxy)** — это структурный паттерн, предоставляющий объект-заменитель для контроля доступа к другому объекту. Прокси может выполнять дополнительные действия (кеширование, ленивая инициализация, проверка прав) перед передачей запроса оригинальному объекту.

#### **2. Код-пример**  
**Пример: Ленивая загрузка изображения**  
```cpp
#include <iostream>
#include <memory>

// Интерфейс
class Image {
public:
    virtual ~Image() = default;
    virtual void display() = 0;
};

// Реальный объект (ресурсоёмкий)
class RealImage : public Image {
    std::string filename;
    void loadFromDisk() {
        std::cout << "Loading " << filename << " (heavy operation)\n";
    }
public:
    RealImage(const std::string& filename) : filename(filename) {
        loadFromDisk();
    }
    void display() override {
        std::cout << "Displaying " << filename << "\n";
    }
};

// Прокси (ленивая инициализация)
class ImageProxy : public Image {
    std::string filename;
    std::unique_ptr<RealImage> realImage;
public:
    ImageProxy(const std::string& filename) : filename(filename) {}
    void display() override {
        if (!realImage) {
            realImage = std::make_unique<RealImage>(filename);
        }
        realImage->display();
    }
};

int main() {
    ImageProxy proxy("photo.jpg");
    std::cout << "Proxy created (image not loaded yet).\n";
    proxy.display(); // Загрузка при первом вызове
    proxy.display(); // Используется существующий объект
}
```
**Вывод:**  
```
Proxy created (image not loaded yet).
Loading photo.jpg (heavy operation)
Displaying photo.jpg
Displaying photo.jpg
```

#### **3. Компоненты и связи**  
- **Subject (Image)**  
  Интерфейс для реального объекта и прокси.  
- **RealSubject (RealImage)**  
  Ресурсоёмкий объект, который прокси контролирует.  
- **Proxy (ImageProxy)**  
  Заместитель, управляющий доступом (например, ленивая загрузка).  

#### **4. Плюсы паттерна**  
- **Контроль доступа**: Проверка прав, ленивая инициализация.  
- **Кеширование**: Сохранение результатов дорогих операций.  
- **Гибкость**: Добавление логики без изменения основного объекта.  

#### **5. Когда использовать?**  
- Ленивая загрузка ресурсов (изображения, БД).  
- Защита API (авторизация).  
- Удалённые сервисы (RPC, REST).  
- Логирование и мониторинг вызовов.  

#### **6. Подводные камни и решения**  
**Минусы:**  
- **Усложнение кода**: Введение дополнительных классов.  
- **Накладные расходы**: Задержки из-за проверок в прокси.  

**Способы решения:**  
- Использовать умные указатели (`std::shared_ptr`) для управления памятью.  
- Оптимизировать условия проверок (например, кешировать результаты авторизации).  
#### **7. Альтернативы и отличия от других паттернов**  

| **Паттерн**       | **Отличие от Proxy**                                                                 |
|-------------------|-------------------------------------------------------------------------------------|
| **Декоратор**     | Добавляет новую функциональность, а Proxy контролирует доступ.                     |
| **Адаптер**       | Изменяет интерфейс объекта, а Proxy сохраняет его.                                 |
| **Фасад**         | Упрощает работу с подсистемой, а Proxy — с одним объектом.                         |
| **Flyweight**     | Оптимизирует память через разделение состояния, а Proxy — управляет доступом.      |

**Идеальный ответ:**
*"Паттерн Proxy предоставляет суррогатный объект для контроля доступа к другому объекту. Используется для ленивой инициализации, кеширования, защиты доступа (например, авторизации). Состоит из интерфейса (Subject), реального объекта (RealSubject) и прокси. Пример — ленивая загрузка изображений. Отличается от Декоратора (добавляет функциональность) и Адаптера (меняет интерфейс). В C++ можно реализовать через умные указатели или ручное управление жизненным циклом, как в примере с ImageProxy."*