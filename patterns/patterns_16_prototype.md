#### **1. Определение**
**Прототип (Prototype)** — это порождающий паттерн, позволяющий создавать новые объекты путем **клонирования существующих экземпляров** вместо использования конструкторов. Особенно полезен, когда создание объекта ресурсоемко или требует сложной логики инициализации.

#### **2. Классическая реализация на C++**

**1. Базовый интерфейс Prototype**
```cpp
class Prototype {
public:
    virtual ~Prototype() = default;
    virtual std::unique_ptr<Prototype> clone() const = 0;
    virtual void describe() const = 0;
};
```

**2. Конкретные прототипы**
```cpp
class NPC : public Prototype {
public:
    NPC(const std::string& name, int health) 
        : name_(name), health_(health) {}

    std::unique_ptr<Prototype> clone() const override {
        return std::make_unique<NPC>(*this); // Использует конструктор копирования
    }

    void describe() const override {
        std::cout << "NPC: " << name_ << " (HP: " << health_ << ")\n";
    }

private:
    std::string name_;
    int health_;
};
```

**3. Клиентский код**
```cpp
void spawnEnemy(const Prototype& prototype) {
    auto enemy = prototype.clone();
    enemy->describe();
}

int main() {
    NPC orc("Orc", 100);
    spawnEnemy(orc); // Создаёт копию орка
}
```
**Вывод:**
```
NPC: Orc (HP: 100)
```

#### **3. Глубокое vs поверхностное копирование**
**Проблема поверхностного копирования:**
```cpp
class Weapon {
public:
    int* damage;
    Weapon(int dmg) { damage = new int(dmg); }
    ~Weapon() { delete damage; }
    // Отсутствует конструктор копирования!
};

Weapon w1(10);
Weapon w2 = w1; // Оба объекта указывают на один damage!
// При удалении w1 и w2 — двойное освобождение памяти!
```

**Решение (глубокое копирование):**
```cpp
class SafeWeapon {
public:
    int* damage;
    SafeWeapon(int dmg) { damage = new int(dmg); }
    SafeWeapon(const SafeWeapon& other) { damage = new int(*other.damage); }
    ~SafeWeapon() { delete damage; }
};
```

#### **4. Плюсы и минусы**
| **Преимущества**               | **Недостатки**                  |
|--------------------------------|---------------------------------|
| ✅ Ускоряет создание объектов  | ❌ Сложность клонирования объектов с циклическими ссылками |
| ✅ Избегает повторной сложной инициализации | ❌ Необходимость реализации `clone()` для каждого класса |
| ✅ Позволяет динамически конфигурировать объекты | |

#### **5. Когда использовать?**
- **Ресурсоемкие объекты** (загрузка текстур, подключение к БД).
- **Системы с множеством однотипных объектов** (игровые NPC, UI-элементы).
- **Когда нужно скрыть сложность создания объектов** от клиентского кода.

#### **6. Сравнение с другими паттернами**
| **Паттерн**       | **Ключевое отличие**                     |
|--------------------|------------------------------------------|
| **Фабрика**        | Создаёт объекты "с нуля"                 |
| **Строитель**      | Пошаговое конструирование сложных объектов |
| **Прототип**       | Клонирование готовых экземпляров         |

#### **7. Реальные примеры**
- **Графические редакторы**: Клонирование фигур, слоев.
- **Игровые движки**: Создание копий персонажей, снарядов.
- **STL**: Копирование контейнеров (`std::vector<T> copy = original;`).

**Идеальный ответ:**  
*"Паттерн Прототип позволяет создавать объекты через клонирование существующих экземпляров, что особенно полезно при работе с ресурсоемкими или сложно настраиваемыми объектами. Реализуется через: 1) интерфейс с методом `clone()`, 2) конкретные прототипы, поддерживающие копирование. Важно учитывать разницу между поверхностным и глубоким копированием. Преимущества: производительность и гибкость. Недостатки: сложность с циклическими ссылками. Применяется в играх, графических редакторах и системах, где требуется быстрое создание однотипных объектов."*