#### **1. Определение стабильности**  
Алгоритм сортировки называется **стабильным**, если он сохраняет **относительный порядок элементов с одинаковыми ключами** после сортировки.  

**Пример**:  
```plaintext
Исходный массив: [3a, 2, 3b, 1]  
Стабильная сортировка: [1, 2, 3a, 3b]  (порядок 3a и 3b сохранён)  
Нестабильная сортировка: [1, 2, 3b, 3a]  (порядок изменён)  
```

#### **2. Почему MergeSort стабильна?**  
**MergeSort** гарантирует стабильность благодаря двум ключевым особенностям:  

1. **Разделение без перестановок**  
   - Массив рекурсивно делится на подмассивы **без изменения порядка элементов**.  
   - Пример:  
     ```plaintext
     Разделение [3a, 2, 3b, 1] → [3a, 2] и [3b, 1] (порядок 3a и 3b не нарушен).
     ```  

2. **Слияние с приоритетом левого элемента**  
   - При слиянии двух подмассивов, если встречаются одинаковые элементы, **первым выбирается элемент из левого подмассива**.  
   - Пример кода:  
     ```cpp
     if (left[i] <= right[j]) {  // <= сохраняет порядок
         result[k++] = left[i++];
     }
     ```  

**Итог**:  
> MergeSort стабильна, потому что:  
> - Не перемещает элементы при разделении.  
> - При слиянии сохраняет исходный порядок одинаковых элементов.  

#### **3. Почему QuickSort нестабильна?**  
**QuickSort** теряет стабильность из-за:  

1. **Агрессивное перераспределение элементов**  
   - В фазе `partition` элементы переставляются относительно **pivot**, что может изменить порядок одинаковых ключей.  
   - Пример:  
     ```plaintext
     До partition: [3a, 3b, 1]  
     После partition: [1, 3b, 3a] (порядок 3a и 3b нарушен).
     ```  

2. **Отсутствие правил для одинаковых элементов**  
   - В стандартной реализации нет проверки на сохранение порядка при `arr[j] == pivot`.  
   - Пример кода:  
     ```cpp
     if (arr[j] < pivot) {  // Игнорирует случаи arr[j] == pivot
         swap(arr[++i], arr[j]);
     }
     ```  

**Итог**:  
> QuickSort нестабильна, потому что:  
> - Активно переставляет элементы вокруг pivot.  
> - Не учитывает относительный порядок одинаковых ключей.  

#### **4. Можно ли сделать QuickSort стабильной?**  
**Теоретически — да**, но это:  
1. Требует **дополнительной памяти** (как в MergeSort).  
2. Усложняет алгоритм (например, хранение исходных индексов).  

**Практически**:  
- QuickSort **обычно используется нестабильной**, так как её преимущество — **сортировка на месте** ($O(1)$ памяти).
- Для стабильности выбирают **MergeSort** или **TimSort**.

#### **5. Сравнение стабильности алгоритмов**  

| Алгоритм      | Стабильность | Причина                            |
| ------------- | ------------ | ---------------------------------- |
| **MergeSort** | ✅ Да         | Сохраняет порядок при слиянии.     |
| **QuickSort** | ❌ Нет        | Перемещает элементы в `partition`. |
| **TimSort**   | ✅ Да         | Гибрид MergeSort + Insertion Sort. |
| **HeapSort**  | ❌ Нет        | Не учитывает порядок в куче.       |

#### **6. Best Practices**  
- **Если важна стабильность**:  
  - Используйте `std::stable_sort` (реализация MergeSort/TimSort в C++).  
- **Если важна скорость и экономия памяти**:  
  - Выбирайте `std::sort` (Introsort на основе QuickSort).  

**Пример в C++**:  
```cpp
#include <algorithm>
#include <vector>

std::vector<std::pair<int, char>> data = {{3, 'a'}, {2, 'b'}, {3, 'c'}};

// Стабильная сортировка (сохранит порядок пар с ключом 3)
std::stable_sort(data.begin(), data.end());

// Нестабильная сортировка (порядок пар с ключом 3 может измениться)
std::sort(data.begin(), data.end());
```

**Идеальный ответ:**
_**MergeSort** стабильна, потому что не переставляет элементы при разделении и сохраняет их порядок при слиянии. **QuickSort** нестабильна из-за агрессивных перестановок в фазе `partition`, которые нарушают относительный порядок одинаковых ключей. На практике для стабильности используют MergeSort или TimSort, а QuickSort применяют там, где важнее скорость и работа на месте._