#### **1. Определение**  
- **BubbleSort** — простой алгоритм сортировки, основанный на попарном сравнении и обмене соседних элементов.  
- **HeapSort** — алгоритм, использующий структуру данных "бинарная куча" для сортировки.  

#### **2. Сложность BubbleSort**  

| Критерий           | Временная сложность | Объяснение                                                             |
| ------------------ | ------------------- | ---------------------------------------------------------------------- |
| **Худший случай**  | $O(n^2)$            | Массив отсортирован в обратном порядке. Требуется $n(n-1)/2$ операций. |
| **Лучший случай**  | $O(n)$              | Массив уже отсортирован. Достаточно одного прохода.                    |
| **Средний случай** | $O(n^2)$            | Частично упорядоченный массив.                                         |
| **Память**         | $O(1)$              | Сортировка на месте (не требует дополнительной памяти).                |

**Оптимизация**:  
- Если во внутреннем цикле не было обменов, массив уже отсортирован (выход из цикла).  

**Пример кода**:  
```cpp
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; ++i) {
        bool swapped = false;
        for (int j = 0; j < n-i-1; ++j) {
            if (arr[j] > arr[j+1]) {
                std::swap(arr[j], arr[j+1]);
                swapped = true;
            }
        }
        if (!swapped) break;  // Выход, если массив отсортирован
    }
}
```

#### **3. Сложность HeapSort**  

| Критерий           | Временная сложность | Объяснение                                                       |
| ------------------ | ------------------- | ---------------------------------------------------------------- |
| **Худший случай**  | $O(n*log(n))$       | Даже для обратно отсортированного массива.                       |
| **Лучший случай**  | $O(n*log(n))$       | Требует полного построения кучи независимо от исходного порядка. |
| **Средний случай** | $O(n*log(n))$       | Всегда выполняется построение кучи и её поэтапное разбиение.     |
| **Память**         | $O(1)$              | Сортировка на месте (не требует дополнительной памяти).          |

**Пример кода**:  
```cpp
void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2*i + 1;
    int right = 2*i + 2;

    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;

    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(int arr[], int n) {
    for (int i = n/2 - 1; i >= 0; --i) 
        heapify(arr, n, i);

    for (int i = n-1; i > 0; --i) {
        std::swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}
```

#### **4. Сравнение BubbleSort и HeapSort**  

| Критерий         | BubbleSort | HeapSort                           |
| ---------------- | ---------- | ---------------------------------- |
| **Сложность**    | $O(n^2)$   | $O(n*log(n))$                      |
| **Память**       | $O(1)$     | $O(1)$                             |
| **Стабильность** | ✅ Да       | ❌ Нет                              |
| **Применение**   | Обучение   | Реальные приложения (ОС, embedded) |

#### **5. Применение**  
- **BubbleSort**:  
  - Используется только в учебных целях из-за низкой эффективности.  
- **HeapSort**:  
  - Применяется в системах, где важна **предсказуемость времени выполнения** (например, ядро Linux).  
  - Альтернатива QuickSort при невозможности использования дополнительной памяти.  

#### **6. Best Practices**  
- **Не используйте BubbleSort** в реальных проектах.  
- **HeapSort** выбирайте, если:
  - Требуется гарантированная сложность $O(n*log(n))$.
  - Нельзя использовать рекурсию или дополнительную память (как в Merge Sort).  

**Пример в C++**:  
```cpp
#include <algorithm>
#include <vector>

std::vector<int> data = {5, 1, 3, 9, 2};
std::sort(data.begin(), data.end());  // Introsort (гибрид QuickSort + HeapSort)
```

**Идеальный ответ:**
_**BubbleSort** имеет сложность $O(n^2)$ в худшем и среднем случаях, $O(n)$ в лучшем, но на практике не применяется. **HeapSort** гарантирует $O(n*log(n))$ в любом случае и работает на месте $(O(1)$ памяти), но неустойчив. Для реальных задач предпочтительны гибридные алгоритмы (например, `std::sort` в C++)._