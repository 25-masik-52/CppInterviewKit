#### **1. Определение**  
Алгоритм Дейкстры — это метод поиска кратчайших путей от заданной начальной вершины до всех остальных в **взвешенном графе с неотрицательными весами**. Приоритетная очередь (min-heap) используется для оптимизации выбора вершины с минимальным текущим расстоянием.

#### **2. Основные понятия**  
- **Приоритетная очередь (min-heap):**  
  - Позволяет эффективно извлекать вершину с минимальным расстоянием за `O(log V)`.
  - В C++ реализуется через `std::priority_queue` с компаратором `std::greater<>`.  
- **Ключевые шаги алгоритма:**  
  1. Инициализация расстояний (`0` для стартовой вершины, `∞` для остальных).  
  2. Добавление стартовой вершины в очередь.  
  3. Извлечение вершины с минимальным расстоянием и обновление расстояний до её соседей.  

#### **3. Реализация в C++**  
```cpp
#include <queue>
#include <vector>
#include <climits>

void dijkstra(int start, const std::vector<std::vector<std::pair<int, int>>>& graph) {
    int n = graph.size();
    std::vector<int> dist(n, INT_MAX);
    dist[start] = 0;

    // Min-heap: {расстояние, вершина}
    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> pq;
    pq.push({0, start});

    while (!pq.empty()) {
        auto [current_dist, u] = pq.top();
        pq.pop();

        if (current_dist > dist[u]) continue;  // Игнорируем устаревшие записи

        for (const auto& [v, weight] : graph[u]) {
            if (dist[v] > dist[u] + weight) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});  // Добавляем обновлённое расстояние
            }
        }
    }
}
```

#### **4. Применение и примеры**  
- **GPS-навигация:** поиск оптимального маршрута.  
- **Сетевые протоколы:** маршрутизация данных.  
- **Пример работы:**  
  - Граф: `0 → 1 (вес 10), 0 → 4 (вес 5), 4 → 1 (вес 3)`.  
  - Кратчайший путь из `0` в `1`: `0 → 4 → 1` (суммарный вес = 8).  

#### **5. Плюсы и минусы**  
- **Плюсы:**  
  - Эффективность: `O((V + E) log V)` благодаря min-heap.  
  - Гарантированно находит кратчайшие пути при неотрицательных весах.  
- **Минусы:**  
  - Не работает с отрицательными весами (используйте Беллмана-Форда).  

#### **6. Сравнение с другими подходами**  
| **Метод**               | **Сложность**      | **Где использовать**           |
| ----------------------- | ------------------ | ------------------------------ |
| **Дейкстра (min-heap)** | `O((V + E) log V)` | Графы с весами ≥ 0.            |
| **BFS**                 | `O(V + E)`         | Невзвешенные графы.            |
| **Беллман-Форд**        | `O(V * E)`         | Графы с отрицательными весами. |

#### **7. Best Practices**  
- **Оптимизации:**  
  - Ранний выход при достижении целевой вершины.  
  - Игнорирование устаревших записей в очереди.  
- **Ошибки:**  
  - Использование для графов с отрицательными весами (приведёт к некорректным результатам).  

**Идеальный ответ:**
_Алгоритм Дейкстры с приоритетной очередью использует min-heap для выбора вершины с минимальным текущим расстоянием, обновляя расстояния до соседей. Сложность — `O((V + E) log V)`. Пример реализации на C++ включает обработку устаревших записей и вывод кратчайших путей. Подходит для GPS, сетевой маршрутизации и других задач с неотрицательными весами._