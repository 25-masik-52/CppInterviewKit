#### **1. Определение**  
Обход бинарного дерева — это процесс посещения всех его узлов в определённом порядке. Существует три основных стратегии обхода, отличающихся последовательностью обработки узлов и их потомков.

#### **2. Основные типы обхода**  

##### **2.1. Pre-order (Прямой порядок)**  
**Порядок:**  
1. **Корень** (текущий узел).  
2. **Левый** потомок.  
3. **Правый** потомок.  

**Формула:** `N-L-R` (Node-Left-Right).  

**Когда использовать?**  
- Копирование структуры дерева.  
- Сериализация данных (например, в JSON).  
- Префиксная запись выражений (польская нотация).  

**Пример:**  
```
      A
     / \
    B   C
   / \  
  D   E
```
**Результат:** `A → B → D → E → C`.  

##### **2.2. In-order (Симметричный порядок)**  
**Порядок:**  
1. **Левый** потомок.  
2. **Корень** (текущий узел).  
3. **Правый** потомок.  

**Формула:** `L-N-R` (Left-Node-Right).  

**Когда использовать?**  
- Вывод элементов BST в **отсортированном порядке**.  
- Восстановление инфиксных выражений (например, `(A + B) * C`).  

**Пример (то же дерево):**  
**Результат:** `D → B → E → A → C`.  

##### **2.3. Post-order (Обратный порядок)**  
**Порядок:**  
1. **Левый** потомок.  
2. **Правый** потомок.  
3. **Корень** (текущий узел).  

**Формула:** `L-R-N` (Left-Right-Node).  

**Когда использовать?**  
- Удаление дерева (сначала дети, потом родитель).  
- Постфиксная запись выражений (обратная польская нотация).  
- Вычисление арифметических выражений.  

**Пример (то же дерево):**  
**Результат:** `D → E → B → C → A`.  

#### **3. Сравнение на примере арифметического выражения**  
Дерево для выражения `(2 * (3 + 4))`:  
```
      *
     / \
    2   +
       / \
      3   4
```
- **Pre-order:** `* 2 + 3 4` → Польская нотация.  
- **In-order:** `2 * 3 + 4` → Инфиксная запись (требует скобок).  
- **Post-order:** `2 3 4 + *` → Обратная польская нотация.  

#### **4. Реализация на C++**  
```cpp
struct Node {
    int data;
    Node* left;
    Node* right;
};

// Pre-order
void preOrder(Node* node) {
    if (!node) return;
    cout << node->data << " "; // Корень
    preOrder(node->left);      // Левый
    preOrder(node->right);     // Правый
}

// In-order
void inOrder(Node* node) {
    if (!node) return;
    inOrder(node->left);       // Левый
    cout << node->data << " "; // Корень
    inOrder(node->right);      // Правый
}

// Post-order
void postOrder(Node* node) {
    if (!node) return;
    postOrder(node->left);     // Левый
    postOrder(node->right);    // Правый
    cout << node->data << " "; // Корень
}
```

#### **5. Сводная таблица**  

| Обход       | Порядок | Применение                                  | Пример для BST |
|-------------|---------|--------------------------------------------|----------------|
| **Pre-order**  | N-L-R   | Копирование дерева, префиксные выражения   | `5 → 3 → 1 → 4 → 8 → 7 → 9` |
| **In-order**   | L-N-R   | Сортировка в BST, инфиксные выражения      | `1 → 3 → 4 → 5 → 7 → 8 → 9` |
| **Post-order** | L-R-N   | Удаление дерева, постфиксные выражения     | `1 → 4 → 3 → 7 → 9 → 8 → 5` |

#### **6. Best Practices**  
- **Для BST**:  
  - Используйте **In-order**, чтобы получить отсортированные данные.  
- **Для вычислений**:  
  - **Post-order** подходит для стековых операций (калькуляторы).  
- **Для клонирования**:  
  - **Pre-order** сохраняет структуру дерева.  

**Идеальный ответ:**
_**Pre-order**, **In-order** и **Post-order** — три способа обхода бинарного дерева, отличающиеся порядком посещения узлов:_
*- **Pre-order** (`N-L-R`): Копирование дерева, префиксные выражения.*
*- **In-order** (`L-N-R`): Сортировка в BST, инфиксные выражения.*
*- **Post-order** (`L-R-N`): Удаление дерева, постфиксные выражения.*
*Выбор обхода зависит от задачи: In-order для сортировки, Post-order для вычислений, Pre-order для сохранения структуры.*