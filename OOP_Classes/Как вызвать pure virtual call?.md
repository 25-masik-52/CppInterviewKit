#### **1. Основные способы**
1. **Вызов из конструктора/деструктора базового класса**  
   - В конструкторе или деструкторе базового класса объект ещё/уже не является производным классом, поэтому вызов чисто виртуальной функции приводит к ошибке.  
   - Пример:  
     ```cpp
     class Base {
     public:
         Base() { foo(); } // Pure virtual call!
         virtual void foo() = 0;
     };
     ```

2. **Вызов через удалённый объект**  
   - При удалении объекта в деструкторе базового класса виртуальная функция становится чисто виртуальной.  
   - Пример:  
     ```cpp
     class Base {
     public:
         virtual ~Base() { foo(); } // Pure virtual call!
         virtual void foo() = 0;
     };
     ```

3. **Вызов через нулевой указатель (не всегда)**  
   - Это неопределённое поведение (UB), но в некоторых случаях может привести к `pure virtual call`.  
   - Пример:  
     ```cpp
     Base* obj = nullptr;
     obj->foo(); // UB, возможен краш или pure virtual call.
     ```

#### **2. Критерии возникновения**
| Способ                          | Когда происходит                  | Результат                     |
|---------------------------------|-----------------------------------|-------------------------------|
| Конструктор/деструктор базового класса | Объект не является производным   | Гарантированный `pure virtual call` |
| Удалённый объект               | Объект уже не является производным | Гарантированный `pure virtual call` |
| Нулевой указатель              | Неопределённое поведение          | Возможен краш или `pure virtual call` |

#### **3. Ключевые моменты**
1. **Обязательные условия:**  
   - Наличие чисто виртуальной функции (`= 0`).  
   - Вызов из контекста, где объект не является производным классом (конструктор, деструктор, удалённый объект).  

2. **Дополнительные факторы:**  
   - Поведение зависит от компилятора (Linux/GCC vs Windows/MSVC).  
   - Нулевой указатель не всегда приводит к `pure virtual call` (это UB).  

#### **4. Примеры кода**
**1. Конструктор базового класса:**  
```cpp
class Base {
public:
    Base() { foo(); } // Pure virtual call!
    virtual void foo() = 0;
};

class Derived : public Base {
public:
    void foo() override {}
};

int main() {
    Derived d; // Краш!
}
```

**2. Деструктор базового класса:**  
```cpp
class Base {
public:
    virtual ~Base() { foo(); } // Pure virtual call!
    virtual void foo() = 0;
};

class Derived : public Base {
public:
    void foo() override {}
};

int main() {
    Base* obj = new Derived();
    delete obj; // Краш!
}
```

**3. Нулевой указатель:**  
```cpp
class Base {
public:
    virtual void foo() = 0;
};

int main() {
    Base* obj = nullptr;
    obj->foo(); // UB, возможен pure virtual call или segfault.
}
```

#### **5. Антипаттерны и предостережения**
1. **Избегайте:**  
   - Вызовов виртуальных функций в конструкторах/деструкторах базового класса.  
   - Работы с объектами, время жизни которых не контролируется.  

2. **Проблемы:**  
   - Невозможность перехватить ошибку (программа аварийно завершается).  
   - Сложность отладки из-за неочевидных причин краша.  

#### **6. Рекомендации**
1. **Для предотвращения:**  
   - Не используйте виртуальные функции в конструкторах/деструкторах.  
   - Применяйте фабрики или методы отложенной инициализации.  
   - Проверяйте указатели перед вызовом методов.  

2. **Для отладки:**  
   - Ищите вызовы виртуальных функций в конструкторах/деструкторах.  
   - Анализируйте стек вызовов при краше.  

**Идеальный ответ:**  
*«Pure virtual call возникает при вызове чисто виртуальной функции из конструктора/деструктора базового класса или через удалённый объект. Чтобы избежать этого, не вызывайте виртуальные методы в конструкторах/деструкторах и контролируйте время жизни объектов. Для отладки ищите такие вызовы в коде.»*