#### **1. Определение + Пример кода**  
**Полиморфизм** — это возможность **одного интерфейса** работать с **разными типами данных** или объектов. В C++ он реализуется через:  
- **Перегрузку функций (compile-time)**  
- **Шаблоны (compile-time)**  
- **Виртуальные функции (runtime)**  

**Примеры:**  

1. **Перегрузка функций (Ad-hoc полиморфизм):**  
   ```cpp
   void print(int x) { cout << "int: " << x; }
   void print(double x) { cout << "double: " << x; }
   ```  

2. **Шаблоны (Параметрический полиморфизм):**  
   ```cpp
   template <typename T>
   T add(T a, T b) { return a + b; }
   ```  

3. **Виртуальные функции (Подтиповый полиморфизм):**  
   ```cpp
   class Shape {
   public:
       virtual void draw() const = 0;  // Абстрактный метод
   };
   class Circle : public Shape {
   public:
       void draw() const override { cout << "○"; }
   };
   ```  

#### **2. Зачем это нужно и где применяется?**  
- **Зачем:**  
  - **Гибкость кода:** Один интерфейс — множество реализаций.  
  - **Упрощение расширения:** Новые типы можно добавить без изменения существующего кода.  
- **Где:**  
  - **GUI:** Отрисовка разных виджетов через `Widget->draw()`.  
  - **Игры:** Обработка различных объектов (`Enemy->attack()`).  
  - **Алгоритмы:** Сортировка разных типов данных через шаблоны.  

#### **3. Типы полиморфизма в C++**  
| **Тип**                 | **Когда используется**            | **Пример**                      |
| ----------------------- | --------------------------------- | ------------------------------- |
| **Перегрузка функций**  | Разное поведение для разных типов | `print(int)` vs `print(double)` |
| **Шаблоны**             | Обобщенное программирование       | `std::vector<T>`                |
| **Виртуальные функции** | Работа с иерархиями классов       | `Shape->draw()`                 |

#### **4. Подводные камни и ошибки**  
- **Для виртуальных функций:**  
  - **Отсутствие `override`:**  
    ```cpp
    class Derived : public Base {
    public:
        void foo() { /*...*/ }  // Без override — случайная перегрузка!
    };
    ```  
  - **Срезка объекта (Slicing):**  
    ```cpp
    Circle circle;
    Shape shape = circle;  // Копируется только Shape-часть!
    shape.draw();          // Вызовется Shape::draw() (если не pure virtual).
    ```  
    **Решение:** Использовать указатели/ссылки (`Shape&`).  

- **Для шаблонов:**  
  - **Неявные требования к типам:**  
    ```cpp
    template <typename T>
    T add(T a, T b) { return a + b; }  // Не сработает для T = vector
    ```  

#### **5. Сравнение подходов**  
| **Критерий**     | **Виртуальные функции**    | **Шаблоны**              |
| ---------------- | -------------------------- | ------------------------ |
| **Время вызова** | Runtime (через vtable)     | Compile-time             |
| **Оверхед**      | Есть (vtable, indirection) | Нет (код генерируется)   |
| **Гибкость**     | Требует общей базы         | Работает с любыми типами |

**Когда что выбирать:**  
- **Шаблоны:** Когда типы разнородны и нет общей базы (`std::sort`).  
- **Виртуальные функции:** Когда нужна runtime-гибкость (`GameEntity->update()`).  

#### **6. Пример из практики**  
**Ситуация:** Плагины для приложения с единым интерфейсом:  
```cpp
class Plugin {
public:
    virtual void execute() = 0;
};

class LoggerPlugin : public Plugin {
public:
    void execute() override { /* Логирование */ }
};

class NetworkPlugin : public Plugin {
public:
    void execute() override { /* Отправка данных */ }
};

// Использование:
std::vector<Plugin*> plugins = {new LoggerPlugin(), new NetworkPlugin()};
for (auto* plugin : plugins) {
    plugin->execute();  // Полиморфный вызов
}
```  

#### **Ключевые моменты для собеседования:**  
✔ **3 вида полиморфизма в C++** (перегрузка, шаблоны, виртуальные функции).  
✔ **`override` и `final`** — всегда явно указывайте переопределение.  
✔ **Срезка объектов** — опасность при работе с копиями.  

**Ошибка новичка:**  
```cpp
class Base {
public:
    virtual void foo() {}
};

class Derived : public Base {
public:
    void foo() {}  // Без override — компилятор не проверит переопределение!
};
```  

**Идеальный ответ:**  
*«Полиморфизм в C++ позволяет писать гибкий код через перегрузку, шаблоны и виртуальные функции. Например, в игре мы можем обрабатывать разные типы врагов через единый интерфейс `Enemy->attack()`, где `attack()` переопределен в каждом подклассе. Для безопасности важно использовать `override` и избегать срезки объектов.»*