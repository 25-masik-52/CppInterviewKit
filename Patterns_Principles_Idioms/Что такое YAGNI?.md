#### 1. **Определение**  
**YAGNI (You Aren’t Gonna Need It)** — принцип разработки, который гласит:  
> *"Не реализуйте функциональность, пока она не понадобится явно"*.  

**Суть**:  
- Отказ от написания кода "на будущее".  
- Фокус на текущих требованиях, а не гипотетических сценариях.  

#### 2. **Примеры нарушения YAGNI**  
**Пример 1: Избыточные абстракции**  
```cpp  
// Плохо: интерфейс для возможных парсеров (хотя нужен только JSON)  
class Parser {  
public:  
    virtual Data parse(const std::string&) = 0;  
};  
```  
**Исправление**:  
```cpp  
class JsonParser {  // Только то, что нужно сейчас  
public:  
    Data parse(const std::string& json);  
};  
```  

**Пример 2: Преждевременная оптимизация**  
```cpp  
// Плохо: thread-safe кэш для однопоточного приложения  
class Cache {  
    std::mutex mtx;  // Избыточно  
    std::unordered_map<std::string, Data> data;  
};  
```  

#### 3. **Почему YAGNI важен?**  
- **Экономит время**: Не тратится на невостребованный код.  
- **Снижает сложность**: Меньше кода → меньше багов.  
- **Упрощает изменения**: Проще модифицировать простые системы.  

#### 4. **Когда можно нарушить YAGNI?**  
- **Критически важные компоненты**: Например, основа безопасности.  
- **Дорогостоящие изменения**: Если позже переделка будет слишком затратной.  

#### 5. **Баланс с другими принципами**  
| Принцип   | Акцент                 |
| --------- | ---------------------- |
| **YAGNI** | Не делай лишнего.      |
| **DRY**   | Устраняй дублирование. |
| **KISS**  | Пиши проще.            |

**Пример баланса**:  
```cpp  
// YAGNI: Нет общего FileProcessor  
// KISS: Простой CSV-ридер  
class CsvReader {  
public:  
    Data read(const std::string& filename);  
};  

// DRY: Общая функция для санитайзинга  
std::string sanitize(const std::string& input);  
```  

#### 6. **Риски нарушения YAGNI**  
- **Технический долг**: Неиспользуемый код требует поддержки.  
- **Переусложнение**: Система становится "монстром".  

**Идеальный ответ:**  
*"YAGNI — это принцип, запрещающий реализацию функциональности 'на будущее'. Он требует писать только тот код, который решает текущие задачи, избегая избыточных абстракций и преждевременных оптимизаций. Например, не стоит создавать интерфейс для всех возможных парсеров, если нужен только JSON. YAGNI экономит время, снижает сложность и минимизирует технический долг. Однако его можно нарушить для критически важных компонентов или когда изменение позже будет слишком дорогим. Главное — баланс с DRY и KISS."*