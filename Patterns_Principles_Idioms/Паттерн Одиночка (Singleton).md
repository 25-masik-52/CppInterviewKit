#### **1. Определение**
**Одиночка** — это порождающий паттерн, который:
- Гарантирует существование **единственного экземпляра** класса
- Предоставляет **глобальную точку доступа** к этому экземпляру

#### **2. Классическая реализация (C++11 и новее)**

**Потокобезопасная версия (Meyer's Singleton)**
```cpp
class Singleton {
private:
    Singleton() = default;            // Приватный конструктор
    ~Singleton() = default;           // Приватный деструктор
    Singleton(const Singleton&) = delete;            // Запрет копирования
    Singleton& operator=(const Singleton&) = delete; // Запрет присваивания

public:
    static Singleton& getInstance() {
        static Singleton instance;    // Потокобезопасная инициализация (C++11)
        return instance;
    }

    void businessLogic() {
        std::cout << "Выполнение бизнес-логики\n";
    }
};
```

**Использование:**
```cpp
Singleton::getInstance().businessLogic();
```

#### **3. Когда использовать?**
- **Логгирование** - единый логгер для всего приложения  
- **Управление ресурсами** - кэши, подключения к БД  
- **Конфигурация** - глобальные настройки программы  

#### **4. Плюсы и минусы**

| **Преимущества**                        | **Недостатки**                                  |
| --------------------------------------- | ----------------------------------------------- |
| ✅ Гарантирует единственность экземпляра | ❌ Усложняет модульное тестирование              |
| ✅ Глобальная точка доступа              | ❌ Нарушает принцип единственной ответственности |
| ✅ Ленивая инициализация                 | ❌ Может стать антипаттерном при злоупотреблении |

#### **5. Потокобезопасность**
В C++11 и новее:
- Локальные статические переменные инициализируются потокобезопасно
- Для более сложных сценариев используйте `std::call_once`

**Пример с `std::call_once`:**
```cpp
class ThreadSafeSingleton {
private:
    static std::unique_ptr<ThreadSafeSingleton> instance;
    static std::once_flag initFlag;
    
    ThreadSafeSingleton() = default;

public:
    static ThreadSafeSingleton& getInstance() {
        std::call_once(initFlag, []() {
            instance.reset(new ThreadSafeSingleton());
        });
        return *instance;
    }
};
```

#### **6. Альтернативы**
1. **Dependency Injection**:
   ```cpp
   class Client {
   public:
       explicit Client(Database& db) : db_(db) {}
   private:
       Database& db_;
   };
   ```
2. **Статические классы** (если не нужно состояние)
3. **Моносостояние (Monostate)**:
   ```cpp
   class Monostate {
   public:
       int getValue() { return value_; }
       void setValue(int v) { value_ = v; }
   private:
       static int value_;
   };
   ```

#### **7. Лучшие практики**
1. Всегда запрещайте копирование и присваивание
2. Используйте ленивую инициализацию
3. Избегайте сложных зависимостей в конструкторе
4. Рассмотрите альтернативы перед применением

**Идеальный ответ:**
*"Singleton гарантирует единственный экземпляр класса с глобальной точкой доступа. В современном C++ рекомендуется реализация через статическую локальную переменную (Meyer's Singleton), которая обеспечивает потокобезопасность и автоматическое уничтожение. Паттерн полезен для логгеров, кэшей и конфигураций, но может усложнить тестирование. Альтернативы - Dependency Injection и статические классы. Главное правило: используйте осторожно и только когда действительно нужен глобальный доступ к единственному экземпляру."*