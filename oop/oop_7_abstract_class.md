#### **1. Определение + Пример кода**  
**Абстрактный класс** — это класс, который содержит **минимум одну чисто виртуальную функцию** (pure virtual), что делает невозможным создание его экземпляров. Он используется как интерфейс или базовый класс для наследования.  

**Пример в C++:**  
```cpp
class Shape {  // Абстрактный класс
public:
    virtual void draw() const = 0;  // Чисто виртуальная функция
    virtual ~Shape() = default;     // Виртуальный деструктор
};

class Circle : public Shape {
public:
    void draw() const override {   // Обязательная реализация
        std::cout << "Drawing a circle\n";
    }
};

// Shape shape;  // Ошибка: нельзя создать экземпляр абстрактного класса
Circle circle;  // OK
```  

#### **2. Зачем это нужно и где применяется?**  
- **Зачем:**  
  - **Определение интерфейса:** Указывает, какие методы должны быть реализованы в производных классах.  
  - **Запрет создания объектов:** Например, класс `Animal` может быть абстрактным, а `Cat` и `Dog` — конкретными.  
- **Где:**  
  - Библиотеки (например, Qt с `QWidget`).  
  - Плагины и API (единый интерфейс для разных реализаций).  

#### **3. Чисто виртуальные функции**  
- **Синтаксис:** `virtual void foo() = 0;`  
- **Особенности:**  
  - Должны быть переопределены в производных классах (иначе они тоже станут абстрактными).  
  - **Могут иметь реализацию** (но это редко используется):  
    ```cpp
    class Abstract {
    public:
        virtual void foo() = 0;
    };
    void Abstract::foo() {  // Реализация по умолчанию
        std::cout << "Default\n";
    }
    ```  

#### **4. Отличие от интерфейсов (в C++)**  
В C++ нет отдельного ключевого слова `interface`, но абстрактный класс **без полей данных и с чисто виртуальными методами** считается аналогом интерфейса:  
```cpp
class ISerializable {  // "Интерфейс"
public:
    virtual void serialize() const = 0;
    virtual ~ISerializable() = default;
};
```  

#### **5. Подводные камни и ошибки**  
- **Ошибки:**  
  - **Не переопределить чисто виртуальную функцию:**  
    ```cpp
    class Derived : public Shape {};  // Ошибка: Derived тоже абстрактный!
    ```  
  - **Отсутствие виртуального деструктора:** Утечка ресурсов при удалении через указатель на базовый класс.  
- **Антипаттерны:**  
  - Добавлять поля данных в интерфейс (нарушает принцип разделения интерфейса и реализации).  

#### **6. Пример из практики**  
**Ситуация:** Реализация графического движка:  
```cpp
class Renderable {  // Абстрактный класс
public:
    virtual void render() const = 0;
    virtual ~Renderable() = default;
};

class Sprite : public Renderable {
public:
    void render() const override { /* ... */ }
};

class ParticleSystem : public Renderable {
public:
    void render() const override { /* ... */ }
};

// Использование:
std::vector<Renderable*> objects;
objects.push_back(new Sprite());
objects.push_back(new ParticleSystem());
for (const auto& obj : objects) {
    obj->render();  // Полиморфный вызов
}
```  

#### **Ключевые моменты для собеседования:**  
✔ **`= 0`** — синтаксис чисто виртуальной функции.  
✔ **Нельзя создать экземпляр** — только через наследников.  
✔ **Виртуальный деструктор** — обязателен для корректного удаления.  

**Ошибка новичка:**  
```cpp
class Abstract {
public:
    virtual void foo() = 0;
    ~Abstract() {}  // Не виртуальный! Утечка при delete через указатель на Abstract.
};
```  

**Идеальный ответ:**  
*«Абстрактный класс в C++ — это класс с чисто виртуальными функциями, который нельзя инстанцировать. Он задает интерфейс для производных классов, например, `Shape` с методом `draw()`. Важно добавлять виртуальный деструктор, чтобы избежать утечек памяти при полиморфном удалении.»*