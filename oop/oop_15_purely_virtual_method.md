#### **1. Определение + Пример кода**  
**Чисто виртуальный метод** (pure virtual function) — это виртуальная функция, которая **не имеет реализации** в базовом классе и **обязана быть переопределена** в производных классах.  

**Синтаксис:**  
```cpp
virtual <тип> <имя_метода>(<аргументы>) = 0;
```  

**Пример:**  
```cpp
class Animal {
public:
    virtual void makeSound() const = 0;  // Чисто виртуальный метод
};

class Cat : public Animal {
public:
    void makeSound() const override {    // Обязательная реализация
        std::cout << "Meow!\n"; 
    }
};
```  

#### **2. Зачем это нужно и где применяется?**  
- **Зачем:**  
  - Создание **интерфейсов** (абстрактных классов), где производные классы **должны** реализовать определённое поведение.  
  - Запрет создания экземпляров базового класса (если класс содержит хотя бы один чисто виртуальный метод, он становится **абстрактным**).  
- **Где:**  
  - **Плагины и API** (например, `IDatabase` с методом `connect()`).  
  - **Игровые движки** (базовый класс `GameEntity` с методом `update()`).  
  - **Шаблоны проектирования** (например, Стратегия или Наблюдатель).  

#### **3. Особенности и подводные камни**  
- **Класс с чисто виртуальным методом нельзя инстанцировать:**  
  ```cpp
  Animal animal;  // Ошибка: Animal — абстрактный класс
  ```  
- **Производный класс тоже становится абстрактным**, если не реализует все чисто виртуальные методы:  
  ```cpp
  class Dog : public Animal {};  // Ошибка: Dog не реализовал makeSound()
  ```  
- **Чисто виртуальные методы могут иметь реализацию** (но вызываются только явно):  
  ```cpp
  class Animal {
  public:
      virtual void makeSound() const = 0;
  };
  void Animal::makeSound() const {  // Реализация по умолчанию
      std::cout << "Default sound\n"; 
  }
  class Cat : public Animal {
  public:
      void makeSound() const override {
          Animal::makeSound();  // Явный вызов
          std::cout << "Meow!\n";
      }
  };
  ```  

#### **4. Сравнение с обычными виртуальными методами**  
| **Критерий**                             | **Чисто виртуальный метод** | **Обычный виртуальный метод** |
| ---------------------------------------- | --------------------------- | ----------------------------- |
| **Реализация в базовом классе**          | Нет (или опционально)       | Обязательна                   |
| **Переопределение в производном классе** | Обязательно                 | Необязательно                 |
| **Инстанцирование базового класса**      | Запрещено                   | Разрешено                     |

#### **5. Пример из практики**  
**Ситуация:** Абстрактный класс для работы с файлами.  
```cpp
class FileHandler {
public:
    virtual void open(const std::string& path) = 0;  // Чисто виртуальные
    virtual void close() = 0;
    virtual ~FileHandler() = default;
};

class TextFile : public FileHandler {
public:
    void open(const std::string& path) override { /* ... */ }
    void close() override { /* ... */ }
};

class BinaryFile : public FileHandler {
public:
    void open(const std::string& path) override { /* ... */ }
    void close() override { /* ... */ }
};
```  

#### **Ключевые моменты для собеседования:**  
✔ **Синтаксис:** `virtual void foo() = 0;`  
✔ **Назначение:**  
  - Создание интерфейсов.  
  - Запрет инстанцирования базового класса.  
✔ **Обязательное переопределение** в производных классах.  

**Ошибка новичка:**  
```cpp
class Abstract {
public:
    virtual void foo() = 0;
};
class Derived : public Abstract {};  // Ошибка: не реализован foo()
```  

**Идеальный ответ:**  
*«Чисто виртуальный метод — это метод без реализации в базовом классе, помеченный синтаксисом `= 0`. Он делает класс абстрактным, запрещая его инстанцирование, и требует обязательного переопределения в производных классах. Например, интерфейс `Drawable` с методом `draw() = 0` гарантирует, что все графические объекты реализуют свою логику отрисовки. Чисто виртуальные методы — основа полиморфизма в C++».*