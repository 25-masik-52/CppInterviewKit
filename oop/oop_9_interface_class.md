#### **1. Определение + Пример кода**  
**Класс-интерфейс** — это абстрактный класс в C++, который:  
- Содержит **только чисто виртуальные методы** (кроме деструктора).  
- Не имеет **полей данных** (может содержать только константы или статические поля).  
- Определяет **контракт** для производных классов.  

**Пример:**  
```cpp
class IAudioPlayer {  // Префикс 'I' для обозначения интерфейса
public:
    virtual void play() = 0;
    virtual void pause() = 0;
    virtual void stop() = 0;
    virtual ~IAudioPlayer() = default;  // Виртуальный деструктор
};

class MP3Player : public IAudioPlayer {
public:
    void play() override { /* Реализация для MP3 */ }
    void pause() override { /* ... */ }
    void stop() override { /* ... */ }
};
```  

#### **2. Зачем это нужно и где применяется?**  
- **Зачем:**  
  - Четкое разделение **интерфейса** и **реализации**.  
  - Возможность **подмены реализаций** (например, для тестирования).  
  - Поддержка **множественного наследования** интерфейсов.  
- **Где:**  
  - Плагины и расширения (например, драйверы устройств).  
  - Кросс-платформенные API (разные реализации для Windows/Linux).  
  - Шаблон проектирования **Strategy**.  

#### **3. Отличие от абстрактного класса**  
| **Критерий**    | **Класс-интерфейс**     | **Абстрактный класс**            |
| --------------- | ----------------------- | -------------------------------- |
| **Поля данных** | Нет (только `static`)   | Могут быть                       |
| **Методы**      | Только pure virtual     | Виртуальные + обычные            |
| **Назначение**  | Контракт для реализации | Частичная реализация + интерфейс |

#### **4. Подводные камни и ошибки**  
- **Ошибки:**  
  - Добавление полей данных → превращение в абстрактный класс.  
  - Отсутствие виртуального деструктора → утечка ресурсов.  
- **Антипаттерны:**  
  - «Толстый интерфейс» (более 5–7 методов).  
  - Наследование от нескольких интерфейсов с одинаковыми методами (неоднозначность).  

#### **5. Пример из практики**  
**Ситуация:** Кросс-платформенный файловый менеджер.  
```cpp
class IFileSystem {  // Интерфейс
public:
    virtual bool readFile(const std::string& path) = 0;
    virtual bool writeFile(const std::string& path) = 0;
    virtual ~IFileSystem() = default;
};

// Реализации для разных ОС
class WindowsFileSystem : public IFileSystem { /* ... */ };
class LinuxFileSystem : public IFileSystem { /* ... */ };

// Использование
std::unique_ptr<IFileSystem> fs = std::make_unique<WindowsFileSystem>();
fs->readFile("C:/data.txt");
```  

#### **Ключевые моменты для собеседования:**  
✔ **Только pure virtual методы** (кроме деструктора).  
✔ **Нет полей данных** — только константы/статические поля.  
✔ **Префикс 'I'** — необязателен, но улучшает читаемость.  
✔ **Виртуальный деструктор** — обязателен.  

**Ошибка новичка:**  
```cpp
class NetworkInterface {
public:
    virtual void sendData() = 0;
    int timeout;  // Поле данных → это уже абстрактный класс!
};
```  

**Идеальный ответ:**  
*«Класс-интерфейс в C++ — это абстрактный класс без полей данных, содержащий только чисто виртуальные методы. Он определяет контракт для производных классов, например, `IDatabase` с методами `connect()` и `query()`. Важно использовать виртуальный деструктор и избегать добавления полей, чтобы сохранить чистоту интерфейса.»*