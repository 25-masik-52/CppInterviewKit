#### **1. Определения**:  
- **Константный метод** — метод класса, объявленный с ключевым словом `const` после списка параметров. Гарантирует, что метод не изменяет состояние объекта (не модифицирует его поля).  
- **Объект-константа** — экземпляр класса, объявленный как `const`. Может вызывать только константные методы.  

#### **2. Подробное объяснение**:  
1. **Синтаксис и семантика**:  
   - Константный метод обозначается суффиксом `const`:  
     ```cpp
     int getValue() const { return value; }
     ```  
   - Такой метод **не может** изменять поля класса (кроме `mutable`-полей) и **не может** вызывать неконстантные методы.  

2. **Зачем нужны**:  
   - Безопасность: предотвращает случайную модификацию объекта.  
   - Работа с константными объектами:  
     ```cpp
     const MyClass obj;
     obj.getValue(); // OK, если getValue() — константный
     ```  

3. **Перегрузка методов**:  
   - Можно иметь константную и неконстантную версии одного метода:  
     ```cpp
     int& getData()       { return data; } // Для неконстантных объектов  
     const int& getData() const { return data; } // Для константных объектов  
     ```  

#### **3. Пример**:  
```cpp  
class Counter {  
    int count = 0;  
    mutable int cache = 0; // Можно изменять даже в const-методах  
public:  
    void increment() { count++; }        // Неконстантный метод  
    int getCount() const { return count; } // Константный метод  
    void updateCache() const { cache++; }  // Допустимо (mutable)  
};  

int main() {  
    const Counter c1;  
    // c1.increment(); // Ошибка: нельзя вызвать неконстантный метод  
    c1.getCount();    // OK  
}  
```  

#### **4.  Исключения и особенности**:  
- **`mutable`-поля**: могут изменяться даже в константных методах (например, для кеширования).  
- **Константные методы и потоки**: если метод логически не изменяет объект, но требует синхронизации, его стоит标记 как `const` и использовать `mutable std::mutex`.  
- **Возврат указателей/ссылок**: константный метод может вернуть неконстантный указатель на данные, что нарушает инкапсуляцию (антипаттерн).  

**Идеальный ответ:**
*"Константные методы гарантируют, что состояние объекта не будет изменено, и позволяют работать с константными объектами. Их следует использовать для всех методов, которые логически не модифицируют объект (Effective C++, Scott Meyers, Item 3)."*  