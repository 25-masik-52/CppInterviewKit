#### **1. Определение + Пример кода**
**Наследование** — это принцип ООП, позволяющий создавать новый класс (производный) на основе существующего (базового), перенимая его свойства и методы.

**Пример в C++:**
```cpp
// Базовый класс
class Animal {
public:
    virtual void makeSound() const {
        std::cout << "Some generic animal sound\n";
    }
    virtual ~Animal() = default;  // Виртуальный деструктор!
};

// Производный класс
class Dog : public Animal {
public:
    void makeSound() const override {  // Переопределение метода
        std::cout << "Woof!\n";
    }
};

// Использование
Animal* animal = new Dog();
animal->makeSound();  // Выведет "Woof!"
delete animal;
```

#### **2. Зачем это нужно и где применяется?**
- **Зачем:**
	- **Повторное использование кода** (наследование реализации).
	- **Полиморфизм** (единый интерфейс для разных классов).
- **Где:**
	- Иерархии объектов (GUI: `Button` → `Widget`).
	- Плагины/расширения (базовый класс + специфичные реализации).

#### **3. Типы наследования в C++**
1. **public** (наиболее частый):
```cpp
class Derived : public Base {};
```
	- Публичные/защищенные методы `Base` остаются такими же в `Derived`.

2. **protected/private** (редкие, для особых случаев):
```cpp
class Derived : private Base {};  // Все методы Base становятся private в Derived.
```

#### **4. Подводные камни и антипаттерны**
- **Ошибки:**
	- **Срезка объекта (Slicing):**
```cpp
Dog dog;
Animal animal = dog;  // Создается копия только Animal-части!
animal.makeSound();   // Выведет "Some generic animal sound" — потеряли полиморфизм.
```
**Решение:** Работать через указатели/ссылки (`Animal&` или `Animal*`).

- **Отсутствие виртуального деструктора:**
```cpp
class Base {
public:
    ~Base() { std::cout << "Base dtor\n"; }  // Не виртуальный!
};

class Derived : public Base {
public:
    ~Derived() { std::cout << "Derived dtor\n"; }
};

Base* obj = new Derived();
delete obj;  // Вызовет только ~Base() — утечка ресурсов!
```
**Решение:** Всегда делать деструктор базового класса `virtual`.

- **Антипаттерны:**
	- **Глубокие иерархии** (>3 уровней) — усложняют поддержку.
	- **Наследование ради наследования** — если нет логической связи (`class Car : public Tree`).

#### **5. Сравнение с альтернативами**
- **Наследование vs Композиция:**
```cpp
// Композиция (предпочтительна в 80% случаев):
class Car {
private:
	Engine engine;  // "Включает" функциональность, а не наследует.
};
```
- **Когда выбирать наследование?**
  Только при отношении «является» (например, `Dog` — это `Animal`).

#### **6. Пример из практики**
**Ситуация:** Реализация графического редактора с фигурами.
```cpp
class Shape {
public:
    virtual void draw() const = 0;
    virtual ~Shape() = default;
};

class Circle : public Shape {
public:
    void draw() const override { /* ... */ }
};

class Square : public Shape {
public:
    void draw() const override { /* ... */ }
};

// Использование полиморфизма
std::vector<Shape*> shapes = {new Circle(), new Square()};
for (const auto& shape : shapes) {
    shape->draw();  // Рисует разные фигуры
}
```

**Итог:**
✔ **Public-наследование** — для полиморфизма.
✔ **Виртуальный деструктор** — обязательно.
✔ **Избегайте slicing** — используйте указатели/ссылки.

**Ошибка на собеседовании:**
```cpp
class Stack : public std::vector<int> {};  // Наследование от STL-контейнера — антипаттерн!
// Лучше: приватное наследование или композиция.
```

**Идеальный ответ:**
_"Наследование в C++ позволяет создавать производные классы на основе базовых, перенимая их свойства и методы. Например, класс `Dog` может наследовать от `Animal` и переопределять метод `makeSound()`. Для полиморфизма ключевы `virtual` и `override`, а также виртуальный деструктор. Важно избегать срезки объектов (используя указатели/ссылки) и глубоких иерархий."_