`std::shared_ptr` **частично потокобезопасен**, но его безопасность зависит от того, **какие операции** выполняются и **как используется объект**, которым он владеет.  

#### **1. Какие операции `shared_ptr` потокобезопасны?**  
Согласно стандарту C++ (начиная с C++11):  

✅ **Атомарные (потокобезопасные) операции**:  
1. **Изменение счётчика ссылок** (`strong_refs`, `weak_refs`):  
   - Копирование `shared_ptr` (увеличение счётчика).  
   - Уничтожение `shared_ptr` (уменьшение счётчика).  
   - Присваивание, `reset()`, `swap()`.  
2. **Работа `weak_ptr`** (`.lock()`, `expired()`).  

❌ **Небезопасные операции (требуют синхронизации)**:  
1. **Изменение самого объекта (`T`)** — если объект не защищён мьютексом.  
2. **Прямой доступ к указателю (`get()`)** — может привести к гонкам (race condition).  
3. **Одновременное чтение/запись `shared_ptr` в разных потоках** (если не используется `std::atomic<std::shared_ptr>`).  

#### **2. Примеры потокобезопасного и небезопасного использования**  

**✅ Безопасно (счётчики ссылок)**  
```cpp
auto shared = std::make_shared<int>(42);

// Поток 1:
auto ptr1 = shared;  // Атомарное увеличение счётчика

// Поток 2:
auto ptr2 = shared;  // Атомарное увеличение счётчика
```  
**Итог**: Счётчик ссылок корректно обновляется в многопоточной среде.  

**❌ Небезопасно (изменение объекта)**  
```cpp
auto shared = std::make_shared<int>(42);

// Поток 1:
*shared = 100;  // Гонка данных (Race Condition)!

// Поток 2:
*shared = 200;  // Неопределённое поведение!
```  
**Решение**: Защитить объект мьютексом.  

**❌ Небезопасно (одновременное изменение `shared_ptr`)**  
```cpp
std::shared_ptr<int> shared = std::make_shared<int>(42);

// Поток 1:
shared = std::make_shared<int>(100);  // Небезопасно!

// Поток 2:
shared = std::make_shared<int>(200);  // Небезопасно!
```  
**Решение**: Использовать `std::atomic<std::shared_ptr>` (C++20) или мьютекс.  

#### **3. Как безопасно использовать `shared_ptr` в многопоточности?**  

**Способ 1: Защита объекта мьютексом**  
```cpp
struct SafeData {
    std::mutex mtx;
    std::shared_ptr<int> data;
};

SafeData shared;
// Поток 1:
{
    std::lock_guard<std::mutex> lock(shared.mtx);
    *shared.data = 100;
}
```  

**Способ 2: `std::atomic<std::shared_ptr>` (C++20)**  
```cpp
std::atomic<std::shared_ptr<int>> atomicShared;

// Поток 1:
atomicShared.store(std::make_shared<int>(100));

// Поток 2:
auto ptr = atomicShared.load();  // Безопасно
```  

**Способ 3: `std::atomic_load`, `std::atomic_store` (до C++20)**  
```cpp
std::shared_ptr<int> shared = std::make_shared<int>(42);

// Поток 1:
std::atomic_store(&shared, std::make_shared<int>(100));

// Поток 2:
auto ptr = std::atomic_load(&shared);
```  

**Идеальный ответ:**  
*"`std::shared_ptr` обеспечивает **частичную потокобезопасность**: атомарные операции с счётчиками ссылок (`strong_refs`, `weak_refs`) безопасны в многопоточной среде (копирование, удаление, `swap`), однако **доступ к самому объекту** требует дополнительной синхронизации (мьютекс, атомарные операции). Прямое изменение `shared_ptr` из разных потоков (например, присваивание нового значения) небезопасно и может привести к гонкам данных — для этого в C++20 появился `std::atomic<std::shared_ptr>`, а до C++20 следует использовать `std::atomic_load`/`std::atomic_store`. **Вывод:** `shared_ptr` безопасно управляет памятью в многопоточной среде, но защита данных объекта и операций с указателем лежит на разработчике."*