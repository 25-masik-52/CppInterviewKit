Да, умные указатели можно использовать с массивами, но есть важные нюансы в зависимости от типа указателя.

#### **1. `std::unique_ptr` для массивов**
Для массивов следует использовать специализированную форму `unique_ptr<T[]>`:
```cpp
#include <memory>

// Создание unique_ptr для массива из 10 int
std::unique_ptr<int[]> arr(new int[10]);

// Доступ к элементам
arr[0] = 42;
arr[1] = 100;

// Автоматическое удаление через delete[]
```

**Особенности:**
- Использует `delete[]` вместо `delete`
- Поддерживает оператор `[]` для доступа к элементам
- Не поддерживает арифметику указателей и итераторы

#### **2. `std::shared_ptr` для массивов**
Для `shared_ptr` ситуация сложнее, так как нет встроенной поддержки массивов:

**Способ 1: С пользовательским deleter**
```cpp
std::shared_ptr<int> arr(new int[10], [](int* p) { delete[] p; });

// Неудобный доступ - нужно использовать get()
arr.get()[0] = 42;
```

**Способ 2: Использование `std::default_delete` (C++17)**
```cpp
std::shared_ptr<int[]> arr(new int[10], std::default_delete<int[]>());

// В C++20 появилась прямая поддержка:
std::shared_ptr<int[]> arr(new int[10]);  // Только C++20
```

#### **3. `std::make_unique` для массивов (C++14)**
```cpp
// Создание массива из 5 элементов
auto arr = std::make_unique<int[]>(5);

// Инициализация (начиная с C++20)
auto arr = std::make_unique<int[]>(5, {1, 2, 3, 4, 5});
```

#### **4. Альтернативы**
1. Использование `std::vector`
Часто лучше использовать `vector` вместо сырых массивов:
```cpp
std::vector<int> vec(10);  // Лучше в большинстве случаев
```
2. Использование `std::array` (для статических массивов)
```cpp
std::array<int, 10> arr;  // Не требует динамического выделения
```

#### **Примеры использования**

**Создание и инициализация массива объектов**
```cpp
class Widget {
public:
    Widget() { std::cout << "Widget created\n"; }
    ~Widget() { std::cout << "Widget destroyed\n"; }
};

// Массив из 5 Widget
auto widgets = std::make_unique<Widget[]>(5);
// При выходе из области видимости все объекты будут корректно уничтожены
```

**Многомерные массивы**
```cpp
// 2D массив 3x4
auto matrix = std::make_unique<std::unique_ptr<int[]>[]>(3);
for (int i = 0; i < 3; ++i) {
    matrix[i] = std::make_unique<int[]>(4);
}
matrix[0][0] = 1;
```

#### **Важные предупреждения**
1. **Не смешивайте формы**:
   ```cpp
   std::unique_ptr<int> ptr(new int[10]);  // Ошибка! Будет использован delete вместо delete[]
   ```
2. **Для `shared_ptr` с массивами**:
   - До C++20 требуется явный deleter
   - Нет оператора `[]`, доступ только через `get()`
3. **Инициализация элементов**:
   - `make_unique<int[]>(N)` не инициализирует элементы (до C++20)
   - Можно использовать `std::make_unique_default_init` (C++20) для явного указания

**Рекомендации**
1. **Предпочитайте `std::vector`** в большинстве случаев
2. Для динамических массивов используйте **`std::unique_ptr<T[]>`**
3. Для `shared_ptr` с массивами **дождитесь C++20** или используйте deleter
4. Всегда проверяйте, что используется правильная форма (`delete` vs `delete[]`)

**Идеальный ответ:**  
*"Умные указатели можно использовать с массивами, но с учётом особенностей:*
*- **`unique_ptr<T[]>`** (C++11) — оптимален для массивов, автоматически вызывает `delete[]` и поддерживает оператор `[]`, но не работает с итераторами.*
*- **`shared_ptr`** до C++20 требует ручного делитера (`delete[]`), а с C++20 поддерживает `shared_ptr<T[]>` напрямую.*
*- **`make_unique<T[]>`** (C++14) создаёт массивы, но инициализация элементов доступна только с C++20."*