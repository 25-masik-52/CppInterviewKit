#### **1. Как работает и устроен `unique_ptr`?**  
`unique_ptr` — это умный указатель, обеспечивающий исключительное владение объектом. При уничтожении `unique_ptr` автоматически освобождает память (вызывая `delete` или `delete[]`).  

**Внутреннее устройство**:  
- Хранит сырой указатель (`T*`).  
- Использует механизм **RAII** (Resource Acquisition Is Initialization).  
- Поддерживает пользовательский deleter (по умолчанию — `default_delete<T>`).  

Пример:  
```cpp
std::unique_ptr<int> ptr(new int(42));  // Владение объектом
```  

 #### **2. Для чего нужен `unique_ptr`?**  
- **Безопасное управление памятью**: автоматическое освобождение ресурса.  
- **Исключительное владение**: только один `unique_ptr` может владеть объектом.  
- **Передача владения**: через `std::move()`.  
- **Работа с полиморфными объектами** (правильный вызов деструктора).  

#### **3. Как сделать так, чтобы в `unique_ptr` были утечки?**  
Обычно `unique_ptr` предотвращает утечки, но можно **намеренно** сделать так:  
- **Циклические ссылки** (если хранить `unique_ptr` внутри класса, который ссылается сам на себя).  
- **Неосторожная работа с сырыми указателями**:  
  ```cpp
  int* raw = new int(100);
  std::unique_ptr<int> ptr(raw);
  std::unique_ptr<int> ptr2(raw);  // Двойное освобождение или утечка!
  ```  
- **Использование `release()` без дальнейшего `delete`**:  
  ```cpp
  int* leaked = ptr.release();  // Теперь память надо удалять вручную!
  ```  

#### **4. Какое присваивание разрешает `unique_ptr`?**  
- **Только перемещение (`move`)**! Копирование запрещено.  
  ```cpp
  std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
  std::unique_ptr<int> ptr2 = std::move(ptr1);  // OK, владение передано
  // std::unique_ptr<int> ptr3 = ptr1;  // Ошибка: копирование запрещено!
  ```  

#### **5. Можно ли сменить владельца у `unique_ptr`?**  
Да, **только через перемещение (`std::move`)**. После перемещения исходный `unique_ptr` становится `nullptr`.  
```cpp
auto ptr1 = std::make_unique<int>(42);
auto ptr2 = std::move(ptr1);  // Владение передано ptr2
assert(ptr1 == nullptr);      // ptr1 теперь пуст
```  

#### **6. В чем разница создания `unique_ptr` через конструктор или через `make_unique`?**

| **Критерий**                | **`new` + конструктор**                         | **`make_unique`** (C++14+)            |
| --------------------------- | ----------------------------------------------- | ------------------------------------- |
| **Исключение безопасности** | Может быть утечка, если `new` бросит исключение | Гарантированно безопасно (нет утечек) |
| **Производительность**      | Два выделения (объект + управляющий блок)       | Одно выделение (оптимизировано)       |
| **Читаемость**              | Менее удобно                                    | Более лаконично                       |

**Пример проблемы с `new`**:  
```cpp
foo(std::unique_ptr<int>(new int(10)), std::unique_ptr<int>(new int(20)));  
// Если второй `new` бросит исключение — утечка первого `int`!  
```  
**Решение через `make_unique`**:  
```cpp
foo(std::make_unique<int>(10), std::make_unique<int>(20));  // Безопасно!  
```  

**Идеальный ответ:**
*"`unique_ptr` — это умный указатель, обеспечивающий исключительное владение объектом с автоматическим освобождением памяти через RAII. Внутри хранит сырой указатель и поддерживает пользовательский deleter. Ключевые особенности: запрет копирования (только перемещение через `std::move`), безопасность исключений при использовании `make_unique` (оптимизированное выделение памяти), и корректное удаление полиморфных объектов."*