#### **1. Аллокация Control Block**  
**Аллокация** (от англ. allocation — распределение) — **это распределение ограниченных ресурсов для максимальной эффективности**.

**a) Стандартный случай (`shared_ptr(new T)`)**
**Два отдельных выделения памяти**:  
   - **Объект `T`**: `new T` (или через кастомный аллокатор).  
   - **Control Block**: создаётся внутри конструктора `shared_ptr`.  
   ```cpp
   auto ptr = std::shared_ptr<int>(new int(42));  
   // Выделения:
   // 1. int* p = new int(42);  
   // 2. ControlBlock* cb = new ControlBlock(p);  
   ```
   **Проблемы**:  
   - **Фрагментация памяти** (2 отдельных аллокации).  
   - **Медленнее** (два обращения к аллокатору).  
   - **Небезопасность при исключениях**: если `new ControlBlock` бросит исключение, утечёт `p`.  

**b) Оптимизация (`make_shared`)**
**Одно выделение (`make_shared`)**:  
	- **Объект `T` и Control Block** размещаются **в одном блоке памяти**.  
	- Используется **placement new** для конструирования `T` внутри выделенного блока.  
   ```cpp
   auto ptr = std::make_shared<int>(42);  
   // Выделение:
   // void* block = operator new(sizeof(ControlBlock) + sizeof(int));  
   // ControlBlock* cb = new (block) ControlBlock();  
   // int* p = new (block + offset) int(42);  
   ```
   **Преимущества**:  
	- **1 аллокация вместо 2** → быстрее, меньше фрагментации.  
	- **Локализация данных** → лучше для кэша процессора.  
	- **Безопасность**: если `make_shared` бросает исключение, память освобождается.  
   **Недостатки**:  
	- **Память освобождается только когда `weak_refs == 0`** (если есть `weak_ptr`, объект `T` уже мёртв, но память не возвращена системе).  

#### **2. Размещение Control Block и объекта в памяти**  

**a) Структура блока в `make_shared`**  
При `make_shared` память выделяется **одним куском**:
```
[ Control Block (refcounts, deleter...) | Object (T) ]  
```

**Выравнивание (alignment)**:  
- Компилятор добавляет **padding**, чтобы `T` был выровнен правильно.  
- Например, если `ControlBlock` занимает 24 байта, а `alignof(int) = 4`, то:  
  ```cpp
  struct CombinedBlock {
      ControlBlock cb;
      char padding[4];  // Выравнивание для int
      int value;
  };
  ```

**b) Размер Control Block**  
Зависит от реализации, но обычно содержит:  
- `strong_refs` (`size_t`)  
- `weak_refs` (`size_t`)  
- Указатель на объект (`T*`)  
- Deleter (`std::function` или указатель на функцию)  
- Аллокатор (если используется `allocate_shared`)  

**Примерный размер**:  
- Без кастомного аллокатора: **3 * sizeof(size_t) + 1 * pointer** ≈ 24–32 байта (x64).  
- С аллокатором: может быть больше.  

#### **3. Кастомные аллокаторы (`allocate_shared`)**  
Если нужен контроль над выделением памяти:  
```cpp
std::pmr::polymorphic_allocator<int> alloc;  
auto ptr = std::allocate_shared<int>(alloc, 42);  
```  

**Как работает**:  
1. Аллокатор выделяет память **для Control Block + объекта**.  
2. Используется **placement new** для инициализации.  

**Особенности**:  
- Если аллокатор **не поддерживает расширенные операции** (например, `realloc`), `make_shared` может отказаться от объединённого выделения.  
- Влияет на **ABI-совместимость** (разные аллокаторы → разный layout памяти).  

#### **4. Освобождение памяти**  

**Когда освобождается объект (`T`)?**  
- При `strong_refs == 0` (даже если `weak_refs > 0`).  

**Когда освобождается Control Block?**  
- Только когда **`strong_refs == 0` и `weak_refs == 0`**.  

	**Проблема в `make_shared`**:  
	- Память **объекта + Control Block** не может быть освобождена, пока есть `weak_ptr`.
	- Это **задерживает возврат памяти системе**, даже если объект уже мёртв.  
	**Решение**:  
	- Если критично **раннее освобождение**, использовать **`shared_ptr(new T)`** (но теряем оптимизацию `make_shared`).  

#### **5. Многопоточные аллокации**  
- **Счётчики ссылок** (`strong_refs`, `weak_refs`) — атомарные (`std::atomic`).  
- **Аллокация памяти** (`new`, `malloc`) **не потокобезопасна** по умолчанию.  
  - Если два потока одновременно создают `make_shared`, аллокатор должен синхронизироваться.  
  - **Глобальные аллокаторы** (например, `libc`) используют **мьютексы**.  

**Оптимизация**:  
- **TCMalloc** / **Jemalloc** уменьшают contention в многопоточных сценариях.  

#### **6. Переиспользование памяти (Object Pool)**  
Если часто создаёте/удаляете `shared_ptr` одного типа, можно использовать **пул объектов:**  
```cpp
std::vector<std::shared_ptr<MyClass>> pool;  

auto get_shared() {  
    if (pool.empty()) {  
        return std::make_shared<MyClass>();  
    }  
    auto ptr = pool.back();  
    pool.pop_back();  
    return ptr;  
}  
```  
**Плюсы**:  
- Снижает нагрузку на аллокатор.  
- Уменьшает фрагментацию.  
**Минусы**:  
- Усложняет код.  
- Может привести к "зависанию" памяти в пуле.  

#### **7. Debug-режимы и санитайзеры**  
- **ASAN (AddressSanitizer)**: детектирует утечки и неверные обращения.  
- **Debug-аллокаторы**:  
  - Заполняют память **спецзначениями** (`0xDEADBEEF`).  
  - Проверяют **double-free** и **use-after-free**.  
**Пример**:  
```cpp
auto ptr = std::shared_ptr<int>(new int(42));  // ASAN проверит корректность delete  
```

**Идеальный ответ:**
*"`shared_ptr` и `weak_ptr` используют сложную систему аллокации, где ключевую роль играет Control Block — структура, хранящая счётчики ссылок, указатель на объект и дополнительные данные (делетер, аллокатор)."*