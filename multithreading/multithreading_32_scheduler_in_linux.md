#### **1. Основные цели планировщика**  
Планировщик (scheduler) в Linux решает следующие задачи:  
- **Справедливое распределение** CPU между процессами и потоками.  
- **Минимизация задержек** для интерактивных приложений (GUI, сервисы).  
- **Поддержка real-time** задач с жёсткими временными ограничениями.  
- **Энергоэффективность** (например, tickless-режим).  

#### **2. Ключевые алгоритмы планирования**  

##### **2.1. CFS (Completely Fair Scheduler)**  
**Для чего**: Стандартный алгоритм для обычных процессов (не real-time).  
**Принципы**:  
- **Виртуальное время (`vruntime`)** — учитывает время, уже использованное процессом. Чем больше процесс использовал CPU, тем выше его `vruntime`.  
- **Красно-чёрное дерево** — выбирает процесс с наименьшим `vruntime` для выполнения.  
- **Динамические приоритеты** — на основе `nice` (от `-20` до `+19`).  

**Пример**:  
```bash
nice -n 10 ./program  # Запуск с низким приоритетом  
sudo nice -n -20 ./critical_program  # Высокий приоритет  
```

##### **2.2. Real-Time (RT) планировщик**  
**Для чего**: Критические задачи (авионика, робототехника).  
**Классы**:  
- **`SCHED_FIFO`**:  
  - Процессы выполняются **до завершения** (или явного `sched_yield`).  
  - Фиксированные приоритеты (`1–99`).  
- **`SCHED_RR`**:  
  - Round-robin для процессов с одинаковым приоритетом (с квантом времени).  

**Пример настройки**:  
```c
struct sched_param param = {.sched_priority = 50};  
sched_setscheduler(0, SCHED_FIFO, &param);  // Установка FIFO  
```

#### **3. Механизмы работы**  

##### **3.1. Многоуровневые очереди**  
- **Real-Time** — высший приоритет.  
- **CFS** — обычные процессы.  
- **Deadline** — задачи с дедлайнами (например, `SCHED_DEADLINE`).  

##### **3.2. Квант времени (timeslice)**  
- Динамически рассчитывается (обычно **1–100 мс**).  
- По истечении кванта процесс может быть вытеснен.  

##### **3.3. Переключение контекста**  
- **Добровольное** (`sleep`, I/O).  
- **Принудительное** (по истечении кванта или при появлении更高оприоритетной задачи).  

##### **3.4. Tickless-режим (`NO_HZ`)**  
Отключает периодические прерывания таймера для экономии энергии.  

#### **4. Настройка и мониторинг**  

##### **4.1. Параметры ядра**  
```bash
sysctl kernel.sched_latency_ns  # Текущий квант CFS (например, 6000000 нс = 6 мс)  
echo 10 > /proc/sys/kernel/sched_child_runs_first  # Приоритет дочерних процессов  
```

##### **4.2. Инструменты**  
```bash
top -H            # Потоки и их приоритеты  
htop              # Визуализация нагрузки CPU  
chrt -p 1234      # Проверить класс планировщика для PID 1234  
perf sched latency  # Анализ задержек  
```

#### **5. Сравнение с другими ОС**  
| **ОС**      | **Алгоритм** | **Особенности**                   |
| ----------- | ------------ | --------------------------------- |
| **Linux**   | CFS + RT     | Справедливость + real-time.       |
| **Windows** | MLFQ         | Динамические приоритеты и кванты. |
| **FreeBSD** | ULE          | Оптимизация под NUMA.             |

#### **6. Примеры поведения**  
- **Интерактивные процессы** (GUI) получают приоритет из-за частых I/O.  
- **CPU-bound задачи** (рендеринг) могут вытесняться для сохранения отзывчивости системы.  
- **Thrashing** — если процессов слишком много, время тратится на переключение контекста.  

**Идеальный ответ:**
*"Планировщик Linux использует **CFS** для справедливого распределения CPU на основе `vruntime` и **Real-Time (FIFO/RR)** для критических задач. Ключевые механизмы:*  
*- Динамические кванты времени (1–100 мс).*  
*- Приоритеты через `nice` и `chrt`.*  
*- Tickless-режим для энергосбережения.*  
*Настройки: `sysctl`, `nice`, `chrt`. Мониторинг: `htop`, `perf`.*  
*Отличия от Windows/FreeBSD: CFS vs MLFQ/ULE."*