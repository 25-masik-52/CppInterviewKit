#### **1. Определение**  
**Deadlock** — это ситуация, когда два или более потока бесконечно блокируют друг друга, ожидая освобождения ресурсов (например, мьютексов), которые удерживаются этими же потоками.  

**Ключевые условия для deadlock** (условия Коффмана):  
1. **Взаимное исключение**: Ресурс (мьютекс) может удерживаться только одним потоком.  
2. **Удержание и ожидание**: Поток удерживает один ресурс и ждёт другой.  
3. **Отсутствие вытеснения**: Ресурс нельзя отнять у потока (освобождается только добровольно).  
4. **Циклическое ожидание**: Потоки образуют цикл, где каждый ждёт ресурс от следующего.  

**2. Минимальное количество мьютексов для deadlock**  
**Необходимо как минимум 2 мьютекса**.  

**Пример**:  
```cpp
#include <thread>
#include <mutex>

std::mutex mtx1, mtx2;

void thread1() {
    mtx1.lock();          // Захватываем первый мьютекс
    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Даём время thread2 захватить mtx2
    mtx2.lock();          // Ждём второй мьютекс (deadlock!)
    mtx2.unlock();
    mtx1.unlock();
}

void thread2() {
    mtx2.lock();          // Захватываем второй мьютекс
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    mtx1.lock();          // Ждём первый мьютекс (deadlock!)
    mtx1.unlock();
    mtx2.unlock();
}

int main() {
    std::thread t1(thread1);
    std::thread t2(thread2);
    t1.join(); t2.join(); // Программа зависнет!
    return 0;
}
```  
**Что происходит**:  
- `thread1` захватывает `mtx1` и ждёт `mtx2`.  
- `thread2` захватывает `mtx2` и ждёт `mtx1`.  
- Оба потока блокируются навсегда.  

#### **3. Как избежать deadlock?**  
1. **Упорядоченный захват мьютексов**:  
   Всегда захватывайте мьютексы в **одинаковом порядке** (например, сначала `mtx1`, потом `mtx2`).  
   ```cpp
   void safeThread() {
       std::lock(mtx1, mtx2); // Захватываем оба атомарно
       std::lock_guard<std::mutex> lock1(mtx1, std::adopt_lock);
       std::lock_guard<std::mutex> lock2(mtx2, std::adopt_lock);
       // ...
   }
   ```  
2. **Использование `std::lock` и `std::scoped_lock` (C++17)**:  
   ```cpp
   std::scoped_lock lock(mtx1, mtx2); // Автоматически избегает deadlock
   ```  
3. **Таймауты**:  
   Используйте `try_lock_for` для `std::timed_mutex`.  
4. **Отказ от вложенных блокировок**:  
   Перепроектируйте код, чтобы уменьшить число критических секций.  

#### **4. Пример с `std::scoped_lock`**  
```cpp
std::mutex mtx1, mtx2;

void safeThread() {
    std::scoped_lock lock(mtx1, mtx2); // Захватывает оба мьютекса безопасно
    // Критическая секция...
} // Автоматическое освобождение
```  

**Идеальный ответ:**
*"Deadlock — это взаимная блокировка потоков, возникающая при циклическом ожидании ресурсов (например, мьютексов). Минимальное количество мьютексов для deadlock — 2. Пример: поток 1 удерживает мьютекс A и ждёт B, а поток 2 удерживает B и ждёт A. Способы избежать: упорядоченный захват, `std::scoped_lock`, таймауты. Best practice: используйте RAII-обёртки (`lock_guard`, `scoped_lock`) и избегайте вложенных блокировок."*