#### **1. Определения**
- **Параллелизм (Parallelism)**  
  Физическое **одновременное** выполнение задач на **разных ядрах CPU**.  
  - Пример: Рендеринг видео на 8 ядрах.  

- **Многопоточность (Multithreading)**  
  Использование **нескольких потоков** в одном процессе. Потоки могут работать как параллельно (на многоядерных CPU), так и конкурентно (на одном ядре).  
  - Пример: Фоновая загрузка файла + обновление UI.  

- **Конкурентность (Concurrency)**  
  Логическое **чередование** задач в одном потоке, создающее иллюзию параллельности.  
  - Пример: Веб-сервер, обрабатывающий множество запросов в одном потоке (Event Loop).  

#### **2. Ключевые различия**
| **Критерий**   | **Параллелизм**          | **Многопоточность**     | **Конкурентность**   |
| -------------- | ------------------------ | ----------------------- | -------------------- |
| **Выполнение** | Одновременное (на ядрах) | Потоки в одном процессе | Чередование задач    |
| **Требования** | Много ядер CPU           | 1+ ядер                 | 1 ядро               |
| **Скорость**   | Максимальная             | Зависит от ядер         | Медленнее            |
| **Сложность**  | Высокая (синхронизация)  | Средняя (блокировки)    | Низкая (но паттерны) |

#### **3. Примеры кода**
- **Параллелизм (C++)**:  
  ```cpp
  std::thread t1([]() { processTask1(); }); // Ядро 1
  std::thread t2([]() { processTask2(); }); // Ядро 2
  t1.join(); t2.join();
  ```  
  **Условие**: Требуется многоядерный CPU.  

- **Многопоточность (конкурентная на одном ядре)**:  
  ```cpp
  std::thread t1([]() { downloadFile(); }); // Чередуется с UI
  renderUI(); // Главный поток
  t1.join();
  ```  

- **Конкурентность (асинхронность, C++20)**:  
  ```cpp
  auto task1 = std::async([]() { fetchData(); }); // Не блокирует поток
  auto task2 = std::async([]() { processData(); });
  ```  

#### **4. Когда что использовать?**
- **Параллелизм**:  
  - Тяжелые вычисления (математика, рендеринг).  
  - **Инструменты**: `std::thread`, OpenMP, CUDA.  

- **Многопоточность**:  
  - Фоновые задачи (загрузка, обработка данных).  
  - **Инструменты**: `std::thread`, `std::mutex`.  

- **Конкурентность**:  
  - I/O-операции (веб-запросы, БД).  
  - **Инструменты**: Корутины (C++20), Boost.Asio.  

#### **5. Плюсы и минусы**
| **Тип**             | **Плюсы**                               | **Минусы**             |
| ------------------- | --------------------------------------- | ---------------------- |
| **Параллелизм**     | Максимальная скорость                   | Сложная синхронизация  |
| **Многопоточность** | Гибкость (параллелизм + конкурентность) | Риск гонок данных      |
| **Конкурентность**  | Эффективность для I/O                   | Не ускоряет CPU-задачи |

#### **6. Главные отличия**
1. **Параллелизм vs Конкурентность**:  
   - Параллелизм — это **одновременность** (аппаратная).  
   - Конкурентность — **иллюзия** одновременности (логическая).  
2. **Многопоточность — это инструмент**:  
   - Может реализовать как параллелизм, так и конкурентность.  
3. **Асинхронность ≠ Потоки**:  
   - Асинхронность (корутины) — конкурентность.  
   - Потоки — параллелизм.  

**Идеальный ответ:**
*"Параллелизм — одновременное выполнение задач на разных ядрах CPU. Многопоточность — использование потоков для параллелизма или конкурентности. Конкурентность — чередование задач в одном потоке. В C++ для параллелизма используют `std::thread`, для конкурентности — корутины (C++20). Параллелизм ускоряет вычисления, конкурентность оптимизирует I/O. Best practice: выбирайте подход под задачу (вычисления → параллелизм, I/O → конкурентность)."*