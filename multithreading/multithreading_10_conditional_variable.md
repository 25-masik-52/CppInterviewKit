#### **1. Определение**  
`std::condition_variable` (условная переменная) — это механизм синхронизации в C++, позволяющий потокам ожидать выполнения определённого условия перед продолжением работы. Используется вместе с мьютексом (`std::mutex`) для безопасного управления доступом к общим данным.

#### **2. Основные понятия**  
- **Ожидание и уведомление**:  
  - Поток может приостановить выполнение (`wait`), пока другой поток не уведомит его (`notify_one` или `notify_all`).  
- **Предикат**: Лямбда-функция, проверяющая условие (например, "очередь не пуста"). Защищает от ложных пробудок (spurious wakeup).  
- **Мьютекс**: Обязателен для синхронизации доступа к общим данным. Используется `std::unique_lock`, так как `wait` временно отпускает мьютекс.  

#### **3. Реализация в C++**  
**Пример: Ожидание данных**  
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
bool data_ready = false;

void consumer() {
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []() { return data_ready; }); // Ждём, пока данные готовы
    std::cout << "Данные получены!\n";
}

void producer() {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    {
        std::lock_guard<std::mutex> lock(mtx);
        data_ready = true;
    }
    cv.notify_one(); // Уведомляем потребителя
}

int main() {
    std::thread t1(consumer);
    std::thread t2(producer);
    t1.join();
    t2.join();
}
```
**Вывод:**  
```
Данные получены!
```

#### **4. Применение и примеры**  
- **Очереди задач**: Потоки ожидают новые задачи в очереди.  
- **Синхронизация событий**: Например, завершение расчётов в одном потоке перед стартом другого.  
- **Ресурсы с ограниченным доступом**: Ожидание освобождения ресурса (например, соединения с БД).  

**Пример: Очередь задач**  
```cpp
std::queue<int> tasks;
std::mutex mtx;
std::condition_variable cv;

void worker() {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, []() { return !tasks.empty(); }); // Ждём задачи
        int task = tasks.front();
        tasks.pop();
        lock.unlock();
        std::cout << "Обработано: " << task << "\n";
    }
}
```

#### **5. Плюсы и минусы**  
| **Преимущества**               | **Недостатки**               |
|--------------------------------|-------------------------------|
| ✅ Гибкость: ожидание условий  | ❌ Сложность отладки          |
| ✅ Эффективность: минимизация активного ожидания | ❌ Риск deadlock при ошибках |

#### **6. Сравнение с другими подходами**  
| **Механизм**            | **Когда использовать?**                     |
|-------------------------|--------------------------------------------|
| `condition_variable`    | Для сложных условий (например, очередь).   |
| `std::future`/`std::async` | Для однократных событий.                |
| Активное ожидание       | Только для очень коротких операций.        |

#### **7. Best Practices**  
1. **Всегда используйте предикат** в `wait()` для защиты от ложных пробудок.  
2. **Сочетайте с `std::unique_lock`**: `wait` отпускает мьютекс автоматически.  
3. **Избегайте "потерянных уведомлений"**: Убедитесь, что `notify` вызывается **после** изменения условия.  
4. **Выбирайте `notify_one()` или `notify_all()`** осознанно:  
   - `notify_one()` — для очередей.  
   - `notify_all()` — для глобальных событий (например, завершения работы).  

**Идеальный ответ:**  
*"`std::condition_variable` — это инструмент синхронизации, позволяющий потокам ждать выполнения условий (например, появления данных в очереди). Работает в связке с мьютексом (`std::unique_lock`) и предикатом для защиты от ложных пробудок. Пример: поток-потребитель ждёт уведомления от потока-производителя. Ключевые методы: `wait()`, `notify_one()`, `notify_all()`. Best practices: всегда использовать предикат, избегать потери уведомлений и выбирать правильный тип `notify`."*