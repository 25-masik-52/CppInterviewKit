#### **1. Определение**  
**`std::lock_guard`** — это RAII-обёртка (Resource Acquisition Is Initialization) для мьютексов в C++, которая автоматически управляет блокировкой и разблокировкой мьютекса. При создании объекта `lock_guard` происходит захват мьютекса, а при выходе из области видимости — его освобождение.  

**Ключевая особенность**:  
- Исключает риск забыть разблокировать мьютекс.  
- Гарантирует безопасность при исключениях.  

#### **2. Как работает?**  
1. **Захват мьютекса**:  
   При создании объекта `lock_guard` вызывается `lock()` для переданного мьютекса.  
   ```cpp
   std::mutex mtx;
   {
       std::lock_guard<std::mutex> lock(mtx); // Мьютекс захвачен
       // Критическая секция...
   } // Мьютекс автоматически освобождён
   ```  
2. **Освобождение мьютекса**:  
   При выходе из области видимости (включая случай исключения) вызывается `unlock()`.  

#### **3. Преимущества**  
| **Преимущество**               | **Описание**                                                                 |
|--------------------------------|-----------------------------------------------------------------------------|
| ✅ Автоматическое управление    | Не нужно вручную вызывать `lock()`/`unlock()`.                              |
| ✅ Безопасность исключений      | Мьютекс освобождается даже при возникновении исключения в критической секции. |
| ✅ Упрощение кода               | Делает код чище и менее подверженным ошибкам.                               |

#### **4. Пример использования**  
```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;
int sharedData = 0;

void safeIncrement() {
    std::lock_guard<std::mutex> lock(mtx); // Захватываем мьютекс
    ++sharedData;                          // Работаем с общими данными
} // Мьютекс освобождается здесь автоматически

int main() {
    std::thread t1(safeIncrement);
    std::thread t2(safeIncrement);
    t1.join(); t2.join();
    std::cout << "Result: " << sharedData << std::endl; // Верный результат: 2
}
```  

#### **5. Ограничения**  
- **Нельзя освободить досрочно**:  
  Для гибкого управления используйте `std::unique_lock`.  
- **Не поддерживает рекурсивные мьютексы**:  
  Если мьютекс уже захвачен, повторный захват приведёт к deadlock.  

#### **6. Сравнение с `std::unique_lock`**  
| **Критерий**          | **`std::lock_guard`**                  | **`std::unique_lock`**                  |
|-----------------------|---------------------------------------|-----------------------------------------|
| **Гибкость**          | Нет (фиксированная область видимости) | Да (можно освобождать досрочно)         |
| **Производительность**| Выше (меньше накладных расходов)      | Ниже (дополнительные возможности)       |
| **Рекурсивность**     | Не поддерживается                     | Поддерживается с `std::recursive_mutex` |

#### **7. Когда использовать?**  
- **Короткие критические секции** (например, инкремент счётчика).  
- **Гарантированное освобождение** мьютекса (например, при обработке исключений).  
- **Упрощение кода** там, где не нужна гибкость `unique_lock`.  

**Идеальный ответ:**  
*"`std::lock_guard` — это RAII-обёртка для мьютексов, обеспечивающая автоматический захват и освобождение блокировки. Применяется для защиты критических секций, гарантирует безопасность при исключениях и упрощает код. Не поддерживает досрочное освобождение — для этого используйте `std::unique_lock`. Пример: защита общего счётчика в многопоточной среде."*