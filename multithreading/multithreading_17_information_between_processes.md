#### **1. Определение**  
Межпроцессное взаимодействие (IPC — Inter-Process Communication) — это набор методов для обмена данными между изолированными процессами, каждый из которых имеет собственное адресное пространство.  

#### **2. Основные методы IPC**  

| **Метод**               | **Описание**                                          | **Пример использования**          | **Плюсы/Минусы**                  |
|-------------------------|------------------------------------------------------|----------------------------------|----------------------------------|
| **1. Файлы**           | Запись/чтение общего файла.                          | Логирование, кэширование.        | ✅ Простота; ❌ Низкая скорость. |
| **2. Каналы (Pipes)**  | Односторонний поток данных (анонимные/именованные).  | Команды shell (`cmd1 cmd2`).     | ✅ Лёгкость; ❌ Односторонние.   |
| **3. Очереди сообщений** | Системные очереди (Message Queues).                 | Микросервисы, события ОС.        | ✅ Асинхронность; ❌ Очереди могут переполняться. |
| **4. Разделяемая память (Shared Memory)** | Общая область памяти.              | Высокопроизводительные вычисления. | ✅ Максимальная скорость; ❌ Требует синхронизации. |
| **5. Сокеты (Sockets)** | Сетевой обмен (локальный или удалённый).            | Клиент-серверные приложения.      | ✅ Гибкость; ❌ Накладные расходы. |
| **6. Сигналы (Signals)** | Асинхронные уведомления (например, `SIGINT`).       | Управление процессами.            | ✅ Простота; ❌ Ограниченные данные. |

#### **3. Примеры реализации**  

**a) Именованные каналы (FIFO)**  
```cpp
// Процесс 1 (запись)
#include <fcntl.h>
#include <unistd.h>
int main() {
    mkfifo("/tmp/myfifo", 0666);
    int fd = open("/tmp/myfifo", O_WRONLY);
    write(fd, "Hello", 6);
    close(fd);
}

// Процесс 2 (чтение)
int main() {
    int fd = open("/tmp/myfifo", O_RDONLY);
    char buf[100];
    read(fd, buf, sizeof(buf));
    printf("Received: %s\n", buf);  // Hello
    close(fd);
}
```

**b) Разделяемая память (POSIX)**  
```cpp
// Процесс 1 (запись)
#include <sys/mman.h>
int main() {
    int fd = shm_open("/myshm", O_CREAT | O_RDWR, 0666);
    ftruncate(fd, 1024);
    int* ptr = (int*)mmap(NULL, 1024, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    *ptr = 42;
    munmap(ptr, 1024);
}

// Процесс 2 (чтение)
int main() {
    int fd = shm_open("/myshm", O_RDONLY, 0666);
    int* ptr = (int*)mmap(NULL, 1024, PROT_READ, MAP_SHARED, fd, 0);
    printf("Value: %d\n", *ptr);  // 42
    munmap(ptr, 1024);
    shm_unlink("/myshm");
}
```

**c) Сокеты (TCP)**  
```cpp
// Сервер
#include <sys/socket.h>
int main() {
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in addr = {AF_INET, htons(8080), INADDR_ANY};
    bind(sock, (struct sockaddr*)&addr, sizeof(addr));
    listen(sock, 5);
    int client = accept(sock, NULL, NULL);
    send(client, "Hello", 6, 0);
    close(client);
}

// Клиент
int main() {
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in addr = {AF_INET, htons(8080), inet_addr("127.0.0.1")};
    connect(sock, (struct sockaddr*)&addr, sizeof(addr));
    char buf[100];
    recv(sock, buf, sizeof(buf), 0);
    printf("Received: %s\n", buf);  // Hello
    close(sock);
}
```

#### **4. Критерии выбора метода**  
| **Сценарий**               | **Лучший метод**       | **Причина**                     |
|----------------------------|-----------------------|---------------------------------|
| Высокая производительность | Shared Memory         | Минимальные задержки.           |
| Простота реализации        | Pipes / FIFO          | Не требует сложной синхронизации. |
| Сетевое взаимодействие     | Sockets               | Работает между разными машинами. |
| Кроссплатформенность       | Boost.Interprocess    | Единый API для Windows/Unix.    |

#### **5. Проблемы и решения**  
- **Синхронизация**: Для shared memory используйте семафоры (`sem_init`) или мьютексы.
- **Безопасность**: Ограничивайте доступ к IPC-объектам (права `chmod`).  
- **Утечки ресурсов**: Всегда закрывайте дескрипторы (`close`, `shm_unlink`).  

#### **6. Best Practices**  
1. **Для скорости**: Shared Memory + семафоры.  
2. **Для простоты**: Именованные каналы (FIFO).  
3. **Для сети**: TCP-сокеты (надежность) или UDP (низкие задержки).  
4. **Избегайте busy-waiting**: Используйте `select` или `poll` для сокетов.  

**Идеальный ответ:**
*"Для передачи данных между процессами используются методы IPC: файлы, каналы (pipes), очереди сообщений, разделяемая память (shared memory), сокеты и сигналы. Выбор зависит от задачи: shared memory — для скорости, сокеты — для сетевого обмена, каналы — для простоты. Пример: именованный канал (FIFO) позволяет односторонне передавать данные между процессами. Для синхронизации в shared memory применяются семафоры. Best practice: использовать Boost.Interprocess для кроссплатформенности."*