#### **1. Основные различия**  
| **Критерий**               | `std::launch::async`                              | `std::launch::deferred`                        |
|----------------------------|--------------------------------------------------|-----------------------------------------------|
| **Способ запуска**         | Немедленно в новом потоке.                       | Лениво (при вызове `get()`/`wait()`).         |
| **Параллельность**         | Да (асинхронное выполнение).                     | Нет (выполняется в вызывающем потоке).        |
| **Создание потоков**       | Да.                                              | Нет.                                          |
| **Время выполнения**       | Сразу после `std::async`.                        | Только при обращении к `future`.              |
| **Исключения**             | Пробрасываются в `future`.                       | Пробрасываются при вызове `get()`.            |
| **Блокировка `get()`**     | Блокирует, если задача не завершена.             | Запускает и выполняет задачу синхронно.       |

#### **2. Примеры использования**  

##### **2.1 `std::launch::async`**  
**Когда использовать**: Для длительных задач, которые не должны блокировать основной поток.  
```cpp
#include <future>
#include <iostream>

int compute() { return 42; }

int main() {
    auto fut = std::async(std::launch::async, compute);  // Запуск в новом потоке
    std::cout << "Task running in background...\n";
    std::cout << fut.get() << "\n";  // Ожидание результата
}
```  
**Вывод**:  
```
Task running in background...
42
```  

##### **2.2 `std::launch::deferred`**  
**Когда использовать**: Для ленивых вычислений, когда результат может не понадобиться.  
```cpp
#include <future>
#include <iostream>

int compute() { 
    std::cout << "Computing...\n";
    return 42; 
}

int main() {
    auto fut = std::async(std::launch::deferred, compute);  // Задача отложена
    std::cout << "Task is deferred...\n";
    std::cout << fut.get() << "\n";  // Запуск здесь
}
```  
**Вывод**:  
```
Task is deferred...
Computing...
42
```  

#### **3. Комбинация флагов и неявное поведение**  
- Если флаг не указан (`std::async(compute)`), реализация **сама выбирает** стратегию (обычно `async`).  
- **Не рекомендуется** полагаться на неявное поведение в кроссплатформенном коде.  

**Пример (неоднозначное поведение)**:  
```cpp
auto fut = std::async(compute);  // Зависит от реализации
```  

#### **4. Рекомендации по выбору**  
- **`async`**:  
  - Для параллельных задач (например, загрузка данных, сложные вычисления).  
  - Когда нужно гарантированно запустить поток.  
- **`deferred`**:  
  - Для оптимизации (если результат нужен не всегда).  
  - Для ленивой инициализации ресурсов.  

**Лучшая практика**: Всегда указывайте флаг явно.  

**Идеальный ответ:**
*"`std::launch::async` и `std::launch::deferred` определяют стратегию выполнения задач в `std::async`.*  
*- **`async`**: Немедленный запуск в новом потоке (параллельное выполнение).*  
*- **`deferred`**: Отложенный запуск в вызывающем потоке при вызове `get()` (ленивое вычисление).*  
*Выбирайте `async` для фоновых задач, `deferred` для оптимизации. Всегда указывайте флаг явно, чтобы избежать неожиданного поведения."*