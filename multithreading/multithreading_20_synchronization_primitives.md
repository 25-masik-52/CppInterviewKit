#### **1. Определение**  
Примитивы синхронизации в C++ — это инструменты стандартной библиотеки, предназначенные для координации работы потоков и безопасного доступа к общим данным. Они предотвращают состояния гонки (race conditions), взаимные блокировки (deadlocks) и другие проблемы многопоточности.

#### **2. Основные примитивы синхронизации**  

##### **1. Мьютексы**  
**Для чего**: Обеспечивают эксклюзивный доступ к общему ресурсу.  

| **Тип**                     | **Описание**                                                                 | **Пример**                                                                 |
|-----------------------------|-----------------------------------------------------------------------------|----------------------------------------------------------------------------|
| `std::mutex`               | Базовый мьютекс. Блокирует доступ для одного потока.                        | ```cpp std::mutex mtx; mtx.lock(); /* ... */ mtx.unlock(); ```             |
| `std::recursive_mutex`     | Позволяет повторную блокировку одним потоком.                               | ```cpp std::recursive_mutex rmtx; rmtx.lock(); rmtx.lock(); /* ... */ ```  |
| `std::shared_mutex` (C++17)| Разделяемый мьютекс: множественное чтение, эксклюзивная запись.             | ```cpp std::shared_mutex sh_mtx; std::shared_lock lock(sh_mtx); /* read */ ``` |

**RAII-обёртки**:  
- `std::lock_guard` — автоматическая блокировка/разблокировка.  
- `std::unique_lock` — гибкая блокировка с отложенной инициализацией.  

```cpp
std::mutex mtx;
{
    std::lock_guard<std::mutex> lock(mtx);  // Блокировка в конструкторе
    // Критическая секция
}  // Разблокировка в деструкторе
```

##### **2. Условные переменные (`std::condition_variable`)**  
**Для чего**: Ожидание событий между потоками.  

```cpp
std::mutex mtx;
std::condition_variable cv;
bool ready = false;

// Поток 1 (ожидание)
std::unique_lock<std::mutex> lock(mtx);
cv.wait(lock, []() { return ready; });

// Поток 2 (уведомление)
{
    std::lock_guard<std::mutex> lock(mtx);
    ready = true;
}
cv.notify_one();  // Или notify_all()
```

##### **3. Атомарные операции (`std::atomic`)**  
**Для чего**: Безопасное изменение переменных без блокировок.  

```cpp
std::atomic<int> counter(0);
++counter;  // Атомарная операция
```

**Поддерживаемые типы**: `int`, `bool`, указатели, тривиально копируемые типы.  

##### **4. Семафоры (`std::counting_semaphore`, C++20)**  
**Для чего**: Ограничение доступа к ресурсу (например, пул потоков).  

```cpp
std::counting_semaphore<10> sem(3);  // Макс. 3 потока
sem.acquire();  // Уменьшает счётчик
// Работа с ресурсом...
sem.release();  // Увеличивает счётчик
```

##### **5. Барьеры (`std::barrier`, C++20)**  
**Для чего**: Синхронизация группы потоков в определённой точке.  

```cpp
std::barrier sync_point(3);  // Ожидание 3 потоков
sync_point.arrive_and_wait();  // Блокировка до достижения барьера
```

##### **6. `std::latch` (C++20)**  
**Для чего**: Однократный барьер для ожидания завершения задач.  

```cpp
std::latch latch(3);  // Ожидание 3 вызовов count_down()
latch.count_down();
latch.wait();  // Блокировка до сброса счётчика
```

##### **7. `std::future` и `std::promise`**  
**Для чего**: Передача результатов между потоками и асинхронное выполнение.  

```cpp
std::future<int> fut = std::async([]() { return 42; });
std::cout << fut.get();  // Ожидание результата
```

#### **3. Сравнение примитивов**  

| **Примитив**               | **Когда использовать**                          | **Плюсы**                          | **Минусы**                |
|----------------------------|-----------------------------------------------|------------------------------------|---------------------------|
| `std::mutex`               | Базовые критические секции.                   | Простота.                          | Риск deadlock.            |
| `std::condition_variable`  | Ожидание событий (например, готовности данных). | Гибкость.                          | Сложность отладки.        |
| `std::atomic`              | Атомарные операции (счётчики, флаги).         | Высокая производительность.        | Ограниченные типы.        |
| `std::counting_semaphore`  | Ограничение доступа (пулы ресурсов).           | Контроль числа потоков.            | Требует C++20.            |
| `std::barrier`             | Синхронизация группы потоков.                 | Удобство для параллельных этапов.  | Требует C++20.            |

#### **4. Опасные ситуации и решения**  

1. **Deadlock**:  
   - **Причина**: Взаимная блокировка (например, `lock(m1); lock(m2)` в одном потоке и `lock(m2); lock(m1)` в другом).  
   - **Решение**: Используйте `std::lock(m1, m2)` или `std::scoped_lock` (C++17).  

2. **Голодание (starvation)**:  
   - **Причина**: Поток долго не может захватить ресурс.  
   - **Решение**: Чередуйте приоритеты или используйте fair-мьютексы.  

3. **False sharing**:  
   - **Причина**: Несколько потоков работают с разными переменными в одной кэш-линии.  
   - **Решение**: Выравнивание данных (`alignas(64)`).  

#### **5. Best Practices**  

1. **Используйте RAII-обёртки** (`lock_guard`, `unique_lock`) для автоматического управления блокировками.  
2. **Избегайте голых мьютексов** — всегда оборачивайте их в `lock_guard` или `unique_lock`.  
3. **Для счётчиков/флагов** предпочитайте `std::atomic` вместо мьютексов.  
4. **Проверяйте `joinable()`** перед завершением потоков.  

**Идеальный ответ:**
*"В C++ для синхронизации потоков используются:*  
*- **Мьютексы** (`std::mutex`, `std::shared_mutex`) для эксклюзивного доступа.*  
*- **Условные переменные** (`std::condition_variable`) для ожидания событий.*  
*- **Атомарные операции** (`std::atomic`) для lock-free доступа.*  
*- **Семафоры и барьеры** (C++20) для сложной синхронизации.*  
*- **`std::future`/`std::promise`** для асинхронных задач.*
*Лучшие практики:*  
*- Используйте `std::lock_guard` для автоматического управления блокировками.*  
*- Для счётчиков применяйте `std::atomic`.*  
*- Избегайте deadlock через `std::scoped_lock`."*