#### **1. Основные преимущества `std::lock_guard`**  
`std::lock_guard` — это RAII-обёртка для мьютексов, обеспечивающая:  
1. **Автоматическое управление блокировкой**:  
   - Блокирует мьютекс при создании.  
   - Разблокирует при выходе из зоны видимости (даже при исключениях).  
2. **Безопасность**: Исключает риск забыть вызвать `unlock()`.  
3. **Простота**: Упрощает код, избавляя от ручного управления мьютексом.  

**Пример**:  
```cpp
std::mutex mtx;
{
    std::lock_guard<std::mutex> lock(mtx);  // Блокировка здесь
    // Критическая секция...
}  // Автоматическая разблокировка
```

#### **2. Типы `lock_guard` в стандартной библиотеке C++**  

##### **1. `std::lock_guard` (базовый)**  
- **Назначение**: Блокировка одного мьютекса.  
- **Особенности**:  
  - Невозможно разблокировать вручную.  
  - Не поддерживает условные переменные.  

**Пример**:  
```cpp
std::mutex mtx;
std::lock_guard<std::mutex> lock(mtx);
```

##### **2. `std::scoped_lock` (C++17)**  
- **Назначение**: Блокировка нескольких мьютексов **без риска deadlock**.  
- **Особенности**:  
  - Использует `std::lock` для атомарного захвата.  
  - Подходит для сложных сценариев с множественными мьютексами.  

**Пример**:  
```cpp
std::mutex mtx1, mtx2;
std::scoped_lock lock(mtx1, mtx2);  // Захватывает оба мьютекса
```

##### **Сравнение с `std::unique_lock`**  
| **Критерий**                       | `std::lock_guard`                   | `std::unique_lock`                       |
| ---------------------------------- | ----------------------------------- | ---------------------------------------- |
| **Гибкость**                       | Только автоматическое управление    | Ручное управление (`lock()`, `unlock()`) |
| **Поддержка `condition_variable`** | ❌ Нет                               | ✅ Да                                     |
| **Производительность**             | Быстрее (меньше накладных расходов) | Медленнее                                |

**Пример `unique_lock`**:  
```cpp
std::mutex mtx;
std::unique_lock<std::mutex> lock(mtx);
lock.unlock();  // Ручная разблокировка
```

#### **3. Когда что использовать?**  
| **Сценарий**                  | **Рекомендуемый класс**    |
| ----------------------------- | -------------------------- |
| Защита одного мьютекса        | `std::lock_guard`          |
| Защита нескольких мьютексов   | `std::scoped_lock` (C++17) |
| Гибкое управление блокировкой | `std::unique_lock`         |

#### **4. Примеры применения**  

**Пример 1: Защита общей переменной**  
```cpp
std::mutex mtx;
int shared_data = 0;

void safe_increment() {
    std::lock_guard<std::mutex> lock(mtx);
    ++shared_data;  // Безопасный инкремент
}
```

**Пример 2: Работа с несколькими мьютексами**  
```cpp
std::mutex mtx1, mtx2;

void transfer_data() {
    std::scoped_lock lock(mtx1, mtx2);  // Захватывает оба мьютекса
    // ... безопасная работа с данными ...
}
```

**Идеальный ответ:**  
*"`std::lock_guard` — это RAII-обёртка для мьютексов, гарантирующая автоматическую блокировку/разблокировку. Основные варианты:*
*1. **`std::lock_guard`** — для простых случаев с одним мьютексом.*
*2. **`std::scoped_lock` (C++17)** — для атомарного захвата нескольких мьютексов.*
*Преимущества: безопасность, простота, отсутствие утечек блокировок. Для гибкого управления используйте `std::unique_lock`."*